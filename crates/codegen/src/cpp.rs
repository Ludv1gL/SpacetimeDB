use crate::CodeIndenter;
use crate::Lang;
use sats_parser::Type::{self, Builtin, UserDefined};
use sats_parser::{
    EnumVariant, Field, Module, ReducerDef, SumTypeDef, TableDef, TableTy, TypeDef, TypeVariant, ProductTypeDef,
};
use std::collections::HashMap;

// Helper function to convert names to PascalCase for C++ types
fn to_pascal_case(name: &str) -> String {
    if name.is_empty() {
        return String::new();
    }
    name.split('_')
        .map(|word| {
            let mut chars = word.chars();
            match chars.next() {
                None => String::new(),
                Some(f) => f.to_uppercase().collect::<String>() + chars.as_str(),
            }
        })
        .collect()
}

// Helper function to convert names to snake_case for C++ filenames or variables
fn to_snake_case(name: &str) -> String {
    if name.is_empty() {
        return String::new();
    }
    let mut s = String::new();
    let mut prev_is_upper = false;
    let mut first_char = true;

    for char_val in name.chars() {
        if char_val.is_uppercase() {
            if !first_char && !prev_is_upper {
                s.push('_');
            }
            s.push(char_val.to_ascii_lowercase());
            prev_is_upper = true;
        } else {
            s.push(char_val);
            prev_is_upper = false;
        }
        first_char = false;
    }
    s
}


pub struct Cpp;

impl Cpp {
    fn sptdb_type_to_cpp_string(&self, module: &Module, ty: &Type) -> String {
        match ty {
            Builtin(b) => match b {
                sats_parser::BuiltinType::Bool => "bool".to_string(),
                sats_parser::BuiltinType::U8 => "uint8_t".to_string(),
                sats_parser::BuiltinType::U16 => "uint16_t".to_string(),
                sats_parser::BuiltinType::U32 => "uint32_t".to_string(),
                sats_parser::BuiltinType::U64 => "uint64_t".to_string(),
                sats_parser::BuiltinType::U128 => "uint128_t".to_string(), // Requires custom type or library
                sats_parser::BuiltinType::U256 => "uint256_t".to_string(), // Requires custom type or library
                sats_parser::BuiltinType::I8 => "int8_t".to_string(),
                sats_parser::BuiltinType::I16 => "int16_t".to_string(),
                sats_parser::BuiltinType::I32 => "int32_t".to_string(),
                sats_parser::BuiltinType::I64 => "int64_t".to_string(),
                sats_parser::BuiltinType::I128 => "int128_t".to_string(), // Requires custom type or library
                sats_parser::BuiltinType::I256 => "int256_t".to_string(), // Requires custom type or library
                sats_parser::BuiltinType::F32 => "float".to_string(),
                sats_parser::BuiltinType::F64 => "double".to_string(),
                sats_parser::BuiltinType::String => "std::string".to_string(),
                sats_parser::BuiltinType::Bytes => "std::vector<std::byte>".to_string(),
                sats_parser::BuiltinType::Address => "SpacetimeDB::Address".to_string(), // Placeholder type
                sats_parser::BuiltinType::Timestamp => "SpacetimeDB::Timestamp".to_string(), // Placeholder type (uint64_t)
                sats_parser::BuiltinType::Identity => "SpacetimeDB::Identity".to_string(), // Placeholder type
                sats_parser::BuiltinType::Unit => "std::monostate".to_string(), // Represents void or empty struct
            },
            UserDefined(ud) => {
                // Check if it's an option
                if ud.name == "option" && ud.type_args.len() == 1 {
                    let inner_type = self.sptdb_type_to_cpp_string(module, &ud.type_args[0]);
                    format!("std::optional<{}>", inner_type)
                } else if ud.name == "vector" && ud.type_args.len() == 1 {
                    let inner_type = self.sptdb_type_to_cpp_string(module, &ud.type_args[0]);
                    format!("std::vector<{}>", inner_type)
                }
                 else {
                    // Assume other user-defined types are structs or enums defined in the schema
                    // Their C++ names will be generated by to_pascal_case(ud.name)
                    // We might need to look up the actual C++ name if it differs from the SpacetimeDB name
                    // For now, assume direct mapping after PascalCase conversion.
                    let type_def = module.types.iter().find(|td| td.name == ud.name);
                    if let Some(td) = type_def {
                         to_pascal_case(&td.name)
                    } else {
                        // This case should ideally not happen if the schema is consistent
                        // Or it could be a built-in generic like map<K,V> if we support it
                        format!("UnknownUserDefinedType_{}", to_pascal_case(&ud.name))
                    }
                }
            }
        }
    }
}

impl Lang for Cpp {
    fn table_filename(&self, _module: &Module, table_def: &TableDef) -> String {
        format!("{}_table.h", to_snake_case(&table_def.name))
    }

    fn type_filename(&self, _module: &Module, type_name: &str) -> String {
        format!("{}.h", to_snake_case(type_name))
    }

    fn reducer_filename(&self, _module: &Module, reducer_name: &str) -> String {
        format!("{}_reducer.h", to_snake_case(reducer_name))
    }

    fn generate_type(&self, module: &Module, type_def: &TypeDef) -> String {
        let mut code = CodeIndenter::new();
        let cpp_type_name = to_pascal_case(&type_def.name);

        code.line(format!("#ifndef {}_{}_H", to_snake_case(&type_def.name).to_uppercase(), "TYPE"));
        code.line(format!("#define {}_{}_H", to_snake_case(&type_def.name).to_uppercase(), "TYPE"));
        code.newline();

        // Standard includes often needed
        code.line("#include <string>");
        code.line("#include <vector>");
        code.line("#include <optional>"); // For option<T>
        code.line("#include <variant>");   // For sum types (unions)
        code.line("#include <cstdint>");  // For fixed-width integers
        code.line("#include <functional>"); // For std::hash in potential future
        code.line("#include <stdexcept>"); // For exceptions in deserialize
        code.line("#include <sstream>");   // For error messages
        code.line("#include <iomanip>");   // For byte vector serialization
        code.line("#include \"bsatn_lib.h\""); // Include bsatn declarations
        code.newline();

        // Forward declare dependencies (other user-defined types)
        // This is a simplified approach. A full dependency analysis might be needed.
        let mut dependencies = std::collections::HashSet::new();
        match &type_def.variant {
            TypeVariant::Product(ptd) => {
                match ptd {
                    ProductTypeDef::Struct { fields, .. } | ProductTypeDef::Tuple { fields, .. } => {
                        for field in fields {
                            if let UserDefined(ud) = &field.ty {
                                if ud.name != "option" && ud.name != "vector" && module.types.iter().any(|t| t.name == ud.name) {
                                     dependencies.insert(to_pascal_case(&ud.name));
                                }
                                for arg in &ud.type_args {
                                    if let UserDefined(inner_ud) = arg {
                                         if inner_ud.name != "option" && inner_ud.name != "vector" && module.types.iter().any(|t| t.name == inner_ud.name) {
                                            dependencies.insert(to_pascal_case(&inner_ud.name));
                                         }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            TypeVariant::Sum(st) => {
                 match st {
                    SumTypeDef::Enum { variants, .. } => { /* Simple enums usually don't have complex type dependencies beyond themselves */ }
                    SumTypeDef::Union { variants, .. } => {
                        for variant in variants {
                            if let Some(ty) = &variant.ty {
                                 if let UserDefined(ud) = ty {
                                     if ud.name != "option" && ud.name != "vector" && module.types.iter().any(|t| t.name == ud.name) {
                                         dependencies.insert(to_pascal_case(&ud.name));
                                     }
                                     for arg in &ud.type_args {
                                         if let UserDefined(inner_ud) = arg {
                                             if inner_ud.name != "option" && inner_ud.name != "vector" && module.types.iter().any(|t| t.name == inner_ud.name) {
                                                dependencies.insert(to_pascal_case(&inner_ud.name));
                                             }
                                         }
                                     }
                                 }
                            }
                        }
                    }
                }
            }
        }
        if !dependencies.is_empty() {
            code.line("// Forward declarations for user-defined types");
            for dep in dependencies {
                if dep != cpp_type_name { // Don't forward declare self
                    code.line(format!("struct {};", dep)); // Assuming all user types are structs for now
                    code.line(format!("void serialize(bsatn::Writer& writer, const {}& value);", dep));
                    code.line(format!("{} deserialize_{}(bsatn::Reader& reader);", dep, dep));
                }
            }
            code.newline();
        }


        match &type_def.variant {
            TypeVariant::Product(ptd) => {
                code.line(format!("struct {} {{", cpp_type_name));
                code.indent();
                match ptd {
                    ProductTypeDef::Struct { fields, .. } => {
                        for field in fields {
                            let field_name_cpp = to_snake_case(&field.name);
                            let type_str = self.sptdb_type_to_cpp_string(module, &field.ty);
                            code.line(format!("{} {};", type_str, field_name_cpp));
                        }
                    }
                    ProductTypeDef::Tuple { fields, .. } => {
                        for (i, field) in fields.iter().enumerate() {
                            let field_name_cpp = format!("field{}", i);
                            let type_str = self.sptdb_type_to_cpp_string(module, &field.ty);
                            code.line(format!("{} {};", type_str, field_name_cpp));
                        }
                    }
                }
                // Default constructor
                code.line(format!("{}() = default;", cpp_type_name));

                // Equality operator
                code.line(format!("bool operator==(const {}& other) const {{", cpp_type_name));
                code.indent();
                match ptd {
                     ProductTypeDef::Struct { fields, .. } => {
                        if fields.is_empty() {
                            code.line("return true; // Or handle as needed for empty structs");
                        } else {
                            let checks: Vec<String> = fields.iter().map(|f| {
                                let field_name_cpp = to_snake_case(&f.name);
                                format!("({} == other.{})", field_name_cpp, field_name_cpp)
                            }).collect();
                            code.line(format!("return {};", checks.join(" &&\n           ")));
                        }
                    }
                    ProductTypeDef::Tuple { fields, .. } => {
                         if fields.is_empty() {
                            code.line("return true;");
                        } else {
                            let checks: Vec<String> = fields.iter().enumerate().map(|(i, _f)| {
                                let field_name_cpp = format!("field{}", i);
                                format!("({} == other.{})", field_name_cpp, field_name_cpp)
                            }).collect();
                            code.line(format!("return {};", checks.join(" &&\n           ")));
                        }
                    }
                }
                code.dedent();
                code.line("}");
                code.newline();
                 // Inequality operator
                code.line(format!("bool operator!=(const {}& other) const {{", cpp_type_name));
                code.indent();
                code.line("return !(*this == other);");
                code.dedent();
                code.line("}");


                code.dedent();
                code.line("};");
            }
            TypeVariant::Sum(st) => {
                match st {
                    SumTypeDef::Enum { variants, .. } => {
                        code.line(format!("enum class {} : uint8_t {{ // Assuming u8 tag", cpp_type_name));
                        code.indent();
                        for (i, variant) in variants.iter().enumerate() {
                            code.line(format!("{} = {},", to_pascal_case(&variant.name), i));
                        }
                        code.dedent();
                        code.line("};");
                    }
                    SumTypeDef::Union { variants, .. } => {
                        // For C++, std::variant is a good way to represent unions.
                        // We need to generate the underlying types for variants with data.
                        let mut variant_types: Vec<String> = Vec::new();
                        for variant in variants {
                            if let Some(ty) = &variant.ty {
                                // If the variant type is complex or needs its own struct:
                                // This part might need to generate helper structs for variant types if they are tuples or anonymous structs.
                                // For now, assume variant types are simple or already defined.
                                variant_types.push(self.sptdb_type_to_cpp_string(module, ty));
                            } else {
                                // For variants with no data, like `None` in an `option`, we can use std::monostate or a specific empty struct.
                                // Or, if it's part of a simple enum-like union, the variant name itself is enough.
                                // For std::variant, each type must be unique. If multiple variants have no data, this needs careful handling.
                                // A common pattern is an outer enum for the tag, and a std::variant for data-carrying variants.
                                // However, the prompt seems to imply generating an enum class for simple enums,
                                // and for sum types with data, it could be more complex.

                                // Let's try to generate helper structs for variants that are tuples
                                if variant.ty.is_none() { // Simple variant, like an enum case
                                     variant_types.push(format!("std::monostate")); // For variants with no data
                                }
                                // This part is tricky. A full sum-type (tagged union) generation is complex.
                                // Let's assume for now that if `ty` is present, it's a named type.
                                // If `ty` is None, it's a simple variant.
                                // The schema parser should ideally differentiate between enum-like sum types and general unions.
                            }
                        }
                        // Filter out duplicates for std::variant
                        variant_types.sort();
                        variant_types.dedup();
                        if variant_types.is_empty() { // Should not happen for a valid union
                             code.line(format!("// Skipping empty union for {}", cpp_type_name));
                        } else {
                            // This is a simplification. True tagged unions would need a tag and a union/variant of actual data types.
                            // Also, the BSATN serialization for sum types needs a tag.
                            // Let's generate an outer enum for tags, and then helper structs for each variant if they carry data,
                            // then a main struct holding the tag and a std::variant.
                            // This is closer to how Rust enums with data work and how BSATN would likely handle them.

                            code.line(format!("// Enum for {} tags", cpp_type_name));
                            code.line(format!("enum class {}_Tag : uint8_t {{", cpp_type_name));
                            code.indent();
                            for (idx, variant) in variants.iter().enumerate() {
                                code.line(format!("{} = {},", to_pascal_case(&variant.name), idx));
                            }
                            code.dedent();
                            code.line("};");
                            code.newline();

                            let mut variant_structs_code = CodeIndenter::new();
                            let mut variant_cpp_types_for_std_variant = Vec::new();

                            for variant in variants {
                                let variant_pascal_name = to_pascal_case(&variant.name);
                                if let Some(ty) = &variant.ty {
                                    // Variant with data. Generate a helper struct for its data.
                                    let helper_struct_name = format!("{}_{}", cpp_type_name, variant_pascal_name);
                                    variant_structs_code.line(format!("struct {} {{", helper_struct_name));
                                    variant_structs_code.indent();
                                    // Assuming 'ty' here is not a tuple that needs further destructuring into fields.
                                    // If 'ty' was a ProductTypeDef::Tuple, we'd make fields field0, field1 etc.
                                    // For now, assume 'ty' is a single, named type.
                                    variant_structs_code.line(format!("{} value;", self.sptdb_type_to_cpp_string(module, ty)));

                                    // Equality for helper struct
                                    variant_structs_code.line(format!("bool operator==(const {}& other) const {{ return value == other.value; }}", helper_struct_name));

                                    variant_structs_code.dedent();
                                    variant_structs_code.line("};");
                                    variant_cpp_types_for_std_variant.push(helper_struct_name);
                                } else {
                                    // Variant without data. We can use std::monostate for the std::variant.
                                    // To make it distinct if multiple such variants exist, we need wrapper structs.
                                    let empty_variant_struct_name = format!("{}_{}", cpp_type_name, variant_pascal_name);
                                     variant_structs_code.line(format!("struct {} {{ // Empty variant", empty_variant_struct_name));
                                     variant_structs_code.indent();
                                     variant_structs_code.line(format!("bool operator==(const {}& /*other*/) const {{ return true; }}", empty_variant_struct_name));
                                     variant_structs_code.dedent();
                                     variant_structs_code.line("};");
                                     variant_cpp_types_for_std_variant.push(empty_variant_struct_name);
                                }
                            }
                            code.append_str(&variant_structs_code.finish());
                            code.newline();

                            // Main struct for the sum type
                            code.line(format!("struct {} {{", cpp_type_name));
                            code.indent();
                            code.line(format!("{}_Tag tag;", cpp_type_name));
                            code.line(format!("std::variant<{}> data;", variant_cpp_types_for_std_variant.join(", ")));
                            code.newline();

                            // Constructors for each variant for easier creation
                            for (idx, variant) in variants.iter().enumerate() {
                                let variant_pascal_name = to_pascal_case(&variant.name);
                                let tag_enum_member = format!("{}_Tag::{}", cpp_type_name, variant_pascal_name);

                                if let Some(ty) = &variant.ty {
                                    let helper_struct_name = format!("{}_{}", cpp_type_name, variant_pascal_name);
                                    let param_type = self.sptdb_type_to_cpp_string(module, ty);
                                    code.line(format!("static {} make_{}({} value) {{", cpp_type_name, to_snake_case(&variant.name), param_type));
                                    code.indent();
                                    code.line(format!("return {{{}, {}{{value}} }};", tag_enum_member, helper_struct_name));
                                    code.dedent();
                                    code.line("}");
                                } else {
                                    let empty_variant_struct_name = format!("{}_{}", cpp_type_name, variant_pascal_name);
                                    code.line(format!("static {} make_{}() {{", cpp_type_name, to_snake_case(&variant.name)));
                                    code.indent();
                                    code.line(format!("return {{{}, {}{{}} }};",tag_enum_member, empty_variant_struct_name));
                                    code.dedent();
                                    code.line("}");
                                }
                            }
                            code.newline();

                            // Equality operator for the sum type
                            code.line(format!("bool operator==(const {}& other) const {{", cpp_type_name));
                            code.indent();
                            code.line("if (tag != other.tag) return false;");
                            code.line("return data == other.data;");
                            code.dedent();
                            code.line("}");
                            code.newline();
                            // Inequality operator
                            code.line(format!("bool operator!=(const {}& other) const {{", cpp_type_name));
                            code.indent();
                            code.line("return !(*this == other);");
                            code.dedent();
                            code.line("}");

                            code.dedent();
                            code.line("};");
                        }
                    }
                }
            }
        }
        code.newline();

        // BSATN Serialization/Deserialization Declarations
        code.line(format!("void serialize(bsatn::Writer& writer, const {}& value);", cpp_type_name));
        code.line(format!("{} deserialize_{}(bsatn::Reader& reader);", cpp_type_name, cpp_type_name));
        code.newline();

        // Hash function specialization (optional, but good for std::unordered_map)
        code.line(format!("// Basic hash support, can be expanded if needed"));
        code.line("namespace std {");
        code.indent();
        code.line(format!("template<> struct hash<{}> {{", cpp_type_name));
        code.indent();
        code.line(format!("size_t operator()(const {}& /* val */) const {{", cpp_type_name));
        code.indent();
        code.line(format!("// TODO: Implement a proper hash function for {}", cpp_type_name));
        code.line("size_t h = 0;");
        // A simple way to combine hashes (Boost's hash_combine logic)
        // for (const auto& field : val.fields) { // pseudo-code
        //    h ^= std::hash<FieldType>{}(field) + 0x9e3779b9 + (h << 6) + (h >> 2);
        // }
        code.line("return h;");
        code.dedent();
        code.line("}");
        code.dedent();
        code.line("};");
        code.dedent();
        code.line("} // namespace std");
        code.newline();

        code.line(format!("#endif // {}_{}_H", to_snake_case(&type_def.name).to_uppercase(), "TYPE"));
        code.finish()
    }

    fn generate_table(&self, module: &Module, table_def: &TableDef) -> String {
        let mut code = CodeIndenter::new();
        let table_name_pascal = to_pascal_case(&table_def.name);
        let cpp_table_class_name = format!("{}Table", table_name_pascal);
        let row_type_name_str = match &table_def.ty {
            TableTy::Ty(t) => self.sptdb_type_to_cpp_string(module, t),
            TableTy::Name(n) => to_pascal_case(n), // Assumes this name is already a C++ type name
        };

        code.line(format!("#ifndef {}_{}_H", to_snake_case(&table_def.name).to_uppercase(), "TABLE"));
        code.line(format!("#define {}_{}_H", to_snake_case(&table_def.name).to_uppercase(), "TABLE"));
        code.newline();

        code.line("#include <string>");
        code.line("#include <vector>");
        code.line("#include <optional>");
        code.line("#include <functional>");
        code.line("#include <cstdint>");
        code.line("#include \"spacetime_sdk_common.h\""); // For EventContext, InternalTableUpdate

        // Include the row type definition
        // Infer row type filename: if it's a user defined type, include its .h
        // This assumes the row_type_name_str is the C++ name of the type.
        let row_type_snake = to_snake_case(&row_type_name_str); // This might not be correct if row_type_name_str is already "std::vector<...>"
                                                                // We need the actual SATS type name for the include.
        let original_row_type_name_for_include = match &table_def.ty {
             TableTy::Ty(UserDefined(ud)) => Some(to_snake_case(&ud.name)),
             TableTy::Name(n) => Some(to_snake_case(n)),
             _ => None, // Builtin types for rows are unlikely for tables or don't need includes
        };
        if let Some(include_name) = original_row_type_name_for_include {
             code.line(format!("#include \"{}.h\"", include_name));
        }


        code.newline();

        code.line(format!("class {} {{", cpp_table_class_name));
        code.line("public:");
        code.indent();
        code.line(format!("using RowType = {};", row_type_name_str));
        code.newline();

        // Primary Key
        if let Some(pk_field_name) = &table_def.primary_key {
            // Find the field in the struct definition to get its type
            let pk_type_str = module.types.iter().find(|td| td.name == row_type_name_str || to_pascal_case(&td.name) == row_type_name_str)
                .and_then(|td| match &td.variant {
                    TypeVariant::Product(ProductTypeDef::Struct{fields,..}) => fields.iter().find(|f| f.name == *pk_field_name),
                    _ => None,
                })
                .map(|f| self.sptdb_type_to_cpp_string(module, &f.ty))
                .unwrap_or_else(|| format!("/* PK type for {} not found */ void*", pk_field_name));

            code.line(format!("// Primary key: {}", pk_field_name));
            code.line(format!("std::optional<RowType> get_by_pk({} pk_value);", pk_type_str));
            code.newline();
        } else {
            code.line("// No primary key defined for this table.");
            code.newline();
        }

        code.line("// Iteration");
        code.line("std::vector<RowType> get_all();");
        code.newline();

        code.line("// Callbacks");
        code.line("using OnInsertCb = std::function<void(const RowType& row, const SpacetimeDB::EventContext& ctx)>;");
        code.line("using OnUpdateCb = std::function<void(const RowType& old_row, const RowType& new_row, const SpacetimeDB::EventContext& ctx)>;");
        code.line("using OnDeleteCb = std::function<void(const RowType& row, const SpacetimeDB::EventContext& ctx)>;");
        code.newline();
        code.line("uint64_t on_insert(OnInsertCb callback);");
        code.line("void remove_on_insert(uint64_t callback_id);");
        code.newline();
        code.line("uint64_t on_update(OnUpdateCb callback);");
        code.line("void remove_on_update(uint64_t callback_id);");
        code.newline();
        code.line("uint64_t on_delete(OnDeleteCb callback);");
        code.line("void remove_on_delete(uint64_t callback_id);");
        code.newline();

        code.line("public: // Internal methods, public for now for simplicity for client interaction");
        code.line("void internal_handle_event(const SpacetimeDB::InternalTableUpdate& update);");
        code.newline();

        code.line("private:");
        code.indent();
        code.line("// TODO: Internal data structures for storing rows, PK index, and callbacks");
        code.line("// std::vector<RowType> rows;");
        code.line("// std::map<PKType, size_t> pk_index; // If PK exists");
        code.line("// std::map<uint64_t, OnInsertCb> insert_callbacks;");
        code.line("// etc.");
        code.dedent();


        code.dedent();
        code.line("};");
        code.newline();
        code.line(format!("#endif // {}_{}_H", to_snake_case(&table_def.name).to_uppercase(), "TABLE"));
        code.finish()
    }

    fn generate_reducer(&self, module: &Module, reducer_def: &ReducerDef) -> String {
        let mut code = CodeIndenter::new();
        let reducer_name_snake = to_snake_case(&reducer_def.name);
        let reducer_name_cpp_func = format!("{}", reducer_name_snake); // Free function

        code.line(format!("#ifndef {}_{}_H", reducer_name_snake.to_uppercase(), "REDUCER"));
        code.line(format!("#define {}_{}_H", reducer_name_snake.to_uppercase(), "REDUCER"));
        code.newline();

        code.line("#include <string>");
        code.line("#include <vector>");
        code.line("#include <future>"); // For std::future
        code.line("#include <stdexcept>"); // For std::runtime_error
        code.line("#include \"bsatn_lib.h\"");
        code.line("#include \"spacetime_sdk_common.h\""); // For SpacetimeDBClient access (e.g. SpacetimeDBClient::instance())

        // Include parameter type definitions
        let mut param_type_includes = std::collections::HashSet::new();
        for param in &reducer_def.params {
             if let UserDefined(ud) = &param.ty {
                // Only include if it's a module-defined type (not option/vector)
                if module.types.iter().any(|t| t.name == ud.name) {
                    param_type_includes.insert(format!("#include \"{}.h\"", to_snake_case(&ud.name)));
                }
                for arg in &ud.type_args {
                     if let UserDefined(inner_ud) = arg {
                         if module.types.iter().any(|t| t.name == inner_ud.name) {
                            param_type_includes.insert(format!("#include \"{}.h\"", to_snake_case(&inner_ud.name)));
                         }
                     }
                }
            }
        }
        for include_line in param_type_includes {
            code.line(include_line);
        }
        code.newline();


        let params_str = reducer_def
            .params
            .iter()
            .map(|p| {
                format!(
                    "{} {}",
                    self.sptdb_type_to_cpp_string(module, &p.ty),
                    to_snake_case(&p.name)
                )
            })
            .collect::<Vec<String>>()
            .join(", ");

        code.line(format!("// Reducer: {}", reducer_def.name));
        // Using void for now, can be std::future<ResponseType> if reducers can return values directly
        code.line(format!("inline void {}({}) {{", reducer_name_cpp_func, params_str));
        code.indent();
        code.line("bsatn::Writer writer;");
        for param in &reducer_def.params {
            let param_name_cpp = to_snake_case(&param.name);
            // Call the generated serialize function for each parameter.
            // Assumes serialize(writer, value) for user types, and writer.write_xxx for builtins.
            // This part needs the BSATN writer to have methods for builtins.
            // And we need to know if a type is a user-defined one to call global serialize
            // vs. a builtin to call writer.write_...
            // For now, let's assume global `serialize` handles all cases or dispatches.
             code.line(format!("serialize(writer, {}); // TODO: Ensure global serialize or writer method exists for this type", param_name_cpp));
        }
        code.newline();
        code.line(format!(
            "SpacetimeDB::SpacetimeDBClient::instance().call_reducer_internal(\"{}\", writer.getBytes());",
            reducer_def.name // Use the original SpacetimeDB name
        ));
        code.dedent();
        code.line("}");
        code.newline();
        code.line(format!("#endif // {}_{}_H", reducer_name_snake.to_uppercase(), "REDUCER"));
        code.finish()
    }

    fn generate_globals(&self, module: &Module) -> Vec<(String, String)> {
        let mut files = Vec::new();
        let mut code_types_h = CodeIndenter::new();
        let mut code_tables_h = CodeIndenter::new();
        let mut code_reducers_h = CodeIndenter::new();
        let mut code_bsatn_lib_h = CodeIndenter::new();
        let mut code_sdk_common_h = CodeIndenter::new(); // For EventContext, InternalTableUpdate
        let mut code_sdk_h = CodeIndenter::new();

        // ==== bsatn_lib.h ====
        code_bsatn_lib_h.line("#ifndef BSATN_LIB_H");
        code_bsatn_lib_h.line("#define BSATN_LIB_H");
        code_bsatn_lib_h.newline();
        code_bsatn_lib_h.line("#include <vector>");
        code_bsatn_lib_h.line("#include <string>");
        code_bsatn_lib_h.line("#include <cstdint>");
        code_bsatn_lib_h.line("#include <stdexcept>"); // For std::runtime_error
        code_bsatn_lib_h.line("#include <cstring>");   // For memcpy
        code_bsatn_lib_h.line("#include <optional>");
        code_bsatn_lib_h.line("#include <variant>");   // For std::monostate
        code_bsatn_lib_h.newline();
        code_bsatn_lib_h.line("namespace bsatn {");
        code_bsatn_lib_h.indent();
        code_bsatn_lib_h.line("class Writer {");
        code_bsatn_lib_h.line("public:");
        code_bsatn_lib_h.indent();
        code_bsatn_lib_h.line("std::vector<std::byte> buffer;");
        code_bsatn_lib_h.line("void write_bool(bool val) { buffer.push_back(static_cast<std::byte>(val ? 1 : 0)); }");
        code_bsatn_lib_h.line("void write_u8(uint8_t val) { buffer.push_back(static_cast<std::byte>(val)); }");
        code_bsatn_lib_h.line("void write_u32_le(uint32_t val) { /* ... */ }");
        code_bsatn_lib_h.line("void write_u64_le(uint64_t val) { /* ... */ }");
        code_bsatn_lib_h.line("void write_string(const std::string& str) { /* write len (u32) then bytes */ }");
        code_bsatn_lib_h.line("void write_bytes(const std::vector<std::byte>& bytes) { /* write len (u32) then bytes */ }");
        code_bsatn_lib_h.line("const std::vector<std::byte>& getBytes() const { return buffer; }");
        code_bsatn_lib_h.dedent();
        code_bsatn_lib_h.line("};");
        code_bsatn_lib_h.newline();
        code_bsatn_lib_h.line("class Reader {");
        code_bsatn_lib_h.line("public:");
        code_bsatn_lib_h.indent();
        code_bsatn_lib_h.line("const std::byte* current = nullptr;");
        code_bsatn_lib_h.line("const std::byte* end = nullptr;");
        code_bsatn_lib_h.line("Reader(const std::vector<std::byte>& data) : current(data.data()), end(data.data() + data.size()) {}");
        code_bsatn_lib_h.line("Reader(const std::byte* data_ptr, size_t len) : current(data_ptr), end(data_ptr + len) {}");
        code_bsatn_lib_h.line("bool read_bool() { /* ... */ return false; }");
        code_bsatn_lib_h.line("uint8_t read_u8() { /* ... */ return 0; }");
        code_bsatn_lib_h.line("uint32_t read_u32_le() { /* ... */ return 0; }");
        code_bsatn_lib_h.line("uint64_t read_u64_le() { /* ... */ return 0; }");
        code_bsatn_lib_h.line("std::string read_string() { /* ... */ return \"\"; }");
        code_bsatn_lib_h.line("std::vector<std::byte> read_bytes() { /* ... */ return {}; }");
        code_bsatn_lib_h.line("template<typename T> void read_into(T& val) { /* ... */ } // For fixed size types");
        code_bsatn_lib_h.line("bool eof() const { return current >= end; }");
        code_bsatn_lib_h.line("size_t remaining_bytes() const { return end - current; }");
        code_bsatn_lib_h.dedent();
        code_bsatn_lib_h.line("};");
        code_bsatn_lib_h.dedent();
        code_bsatn_lib_h.line("} // namespace bsatn");
        code_bsatn_lib_h.newline();
        // Global serialize/deserialize for builtins and option/vector
        code_bsatn_lib_h.line("// Global serialization functions for built-in types and common patterns");
        code_bsatn_lib_h.line("inline void serialize(bsatn::Writer& w, bool v) { w.write_u8(v ? 1 : 0); }");
        code_bsatn_lib_h.line("inline void serialize(bsatn::Writer& w, uint8_t v) { w.write_u8(v); }");
        // ... other builtins (u16, u32, u64, i8, i16, i32, i64, f32, f64, string, bytes)
        code_bsatn_lib_h.line("inline void serialize(bsatn::Writer& w, const std::string& v) { w.write_string(v); }");
        code_bsatn_lib_h.line("inline void serialize(bsatn::Writer& w, const std::vector<std::byte>& v) { w.write_bytes(v); }");
        code_bsatn_lib_h.line("template<typename T> void serialize(bsatn::Writer& w, const std::optional<T>& v);"); // Forward
        code_bsatn_lib_h.line("template<typename T> void serialize(bsatn::Writer& w, const std::vector<T>& v);"); // Forward
        code_bsatn_lib_h.line("inline void serialize(bsatn::Writer& /*w*/, const std::monostate& /*v*/) { /* monostate takes no space */ }");


        code_bsatn_lib_h.line("inline bool deserialize_bool(bsatn::Reader& r) { return r.read_u8() != 0; }");
        code_bsatn_lib_h.line("inline uint8_t deserialize_uint8_t(bsatn::Reader& r) { return r.read_u8(); }");
        // ... other builtins
        code_bsatn_lib_h.line("inline std::string deserialize_std_string(bsatn::Reader& r) { return r.read_string(); }");
        code_bsatn_lib_h.line("inline std::vector<std::byte> deserialize_std_vector_std_byte(bsatn::Reader& r) { return r.read_bytes(); }");
        code_bsatn_lib_h.line("template<typename T> std::optional<T> deserialize_std_optional(bsatn::Reader& r);"); // Forward
        code_bsatn_lib_h.line("template<typename T> std::vector<T> deserialize_std_vector(bsatn::Reader& r);"); // Forward
        code_bsatn_lib_h.line("inline std::monostate deserialize_std_monostate(bsatn::Reader& /*r*/) { return {}; }");
        code_bsatn_lib_h.newline();

        code_bsatn_lib_h.line("// Implementations for optional and vector serializers/deserializers");
        code_bsatn_lib_h.line("template<typename T>");
        code_bsatn_lib_h.line("void serialize(bsatn::Writer& w, const std::optional<T>& v) {");
        code_bsatn_lib_h.indent();
        code_bsatn_lib_h.line("if (v.has_value()) { w.write_u8(1); serialize(w, *v); }");
        code_bsatn_lib_h.line("else { w.write_u8(0); }");
        code_bsatn_lib_h.dedent();
        code_bsatn_lib_h.line("}");
        code_bsatn_lib_h.newline();
        code_bsatn_lib_h.line("// Forward declare a generic deserialize for use in option/vector templates below");
        code_bsatn_lib_h.line("template<typename T> T deserialize(Reader& r);");
        code_bsatn_lib_h.newline();

        code_bsatn_lib_h.line("template<typename T>");
        code_bsatn_lib_h.line("inline std::optional<T> deserialize_std_optional(Reader& r) {");
        code_bsatn_lib_h.indent();
        code_bsatn_lib_h.line("if (r.read_u8() != 0) { return deserialize<T>(r); }");
        code_bsatn_lib_h.line("return std::nullopt;");
        code_bsatn_lib_h.dedent();
        code_bsatn_lib_h.line("}");
        code_bsatn_lib_h.newline();
        code_bsatn_lib_h.line("template<typename T>");
        code_bsatn_lib_h.line("void serialize(bsatn::Writer& w, const std::vector<T>& v) {");
        code_bsatn_lib_h.indent();
        code_bsatn_lib_h.line("w.write_u32_le(static_cast<uint32_t>(v.size()));");
        code_bsatn_lib_h.line("for (const auto& item : v) { serialize(w, item); }");
        code_bsatn_lib_h.dedent();
        code_bsatn_lib_h.line("}");
        code_bsatn_lib_h.newline();
        code_bsatn_lib_h.line("template<typename T>");
        code_bsatn_lib_h.line("inline std::vector<T> deserialize_std_vector(Reader& r) {");
        code_bsatn_lib_h.indent();
        code_bsatn_lib_h.line("uint32_t size = r.read_u32_le();");
        code_bsatn_lib_h.line("std::vector<T> vec; vec.reserve(size);");
        code_bsatn_lib_h.line("for (uint32_t i = 0; i < size; ++i) { vec.push_back(deserialize<T>(r)); }");
        code_bsatn_lib_h.line("return vec;");
        code_bsatn_lib_h.dedent();
        code_bsatn_lib_h.line("}");
        code_bsatn_lib_h.newline();

        code_bsatn_lib_h.line("// Template specializations of generic bsatn::deserialize for built-ins and generated helpers");
        code_bsatn_lib_h.line("template<> inline bool deserialize<bool>(Reader& r) { return deserialize_bool(r); }");
        code_bsatn_lib_h.line("template<> inline uint8_t deserialize<uint8_t>(Reader& r) { return deserialize_uint8_t(r); }");
        // TODO: Add specializations for other builtins like u16, u32, u64, i8, i16, i32, i64, f32, f64
        // Example: template<> inline uint32_t deserialize<uint32_t>(Reader& r) { return r.read_u32_le(); }
        code_bsatn_lib_h.line("template<> inline std::string deserialize<std::string>(Reader& r) { return deserialize_std_string(r); }");
        code_bsatn_lib_h.line("template<> inline std::vector<std::byte> deserialize<std::vector<std::byte>>(Reader& r) { return deserialize_std_vector_std_byte(r); }");
        code_bsatn_lib_h.line("template<> inline std::monostate deserialize<std::monostate>(Reader& r) { return deserialize_std_monostate(r); }");

        code_bsatn_lib_h.line("// These allow deserialize<std::optional<T>>(r) and deserialize<std::vector<T>>(r) to work through the generic system.");
        code_bsatn_lib_h.line("template<typename T> inline std::optional<T> deserialize<std::optional<T>>(Reader& r) { return deserialize_std_optional<T>(r); }");
        code_bsatn_lib_h.line("template<typename T> inline std::vector<T> deserialize<std::vector<T>>(Reader& r) { return deserialize_std_vector<T>(r); }");
        code_bsatn_lib_h.newline();
        code_bsatn_lib_h.line("#endif // BSATN_LIB_H");
        files.push(("bsatn_lib.h".to_string(), code_bsatn_lib_h.finish()));

        // ==== spacetime_sdk_common.h ====
        code_sdk_common_h.line("#ifndef SPACETIME_SDK_COMMON_H");
        code_sdk_common_h.line("#define SPACETIME_SDK_COMMON_H");
        code_sdk_common_h.newline();
        code_sdk_common_h.line("#include <string>");
        code_sdk_common_h.line("#include <vector>");
        code_sdk_common_h.line("#include <cstdint>");
        code_sdk_common_h.line("#include <variant>"); // For InternalTableUpdate payload (if used)
        code_sdk_common_h.newline();
        code_sdk_common_h.line("namespace SpacetimeDB {");
        code_sdk_common_h.indent();
        code_sdk_common_h.line("struct EventContext {");
        code_sdk_common_h.indent();
        code_sdk_common_h.line("uint64_t timestamp = 0;");
        code_sdk_common_h.line("std::string transaction_id; // Or a byte array/identity");
        code_sdk_common_h.line("std::string emitting_reducer;");
        code_sdk_common_h.dedent();
        code_sdk_common_h.line("};");
        code_sdk_common_h.newline();
        code_sdk_common_h.line("struct InternalTableUpdate {");
        code_sdk_common_h.indent();
        code_sdk_common_h.line("enum class UpdateType { Insert, Update, Delete };");
        code_sdk_common_h.line("UpdateType type;");
        code_sdk_common_h.line("std::string table_name;");
        code_sdk_common_h.line("std::vector<std::byte> old_row_data; // BSATN encoded");
        code_sdk_common_h.line("std::vector<std::byte> new_row_data; // BSATN encoded for Insert/Update");
        code_sdk_common_h.line("EventContext context;");
        code_sdk_common_h.dedent();
        code_sdk_common_h.line("};");
        code_sdk_common_h.newline();
        // Forward declare client for reducer access
        code_sdk_common_h.line("class SpacetimeDBClient;");
        code_sdk_common_h.dedent();
        code_sdk_common_h.line("} // namespace SpacetimeDB");
        code_sdk_common_h.newline();
        code_sdk_common_h.line("#endif // SPACETIME_SDK_COMMON_H");
        files.push(("spacetime_sdk_common.h".to_string(), code_sdk_common_h.finish()));


        // ==== types.h ====
        code_types_h.line("#ifndef TYPES_H_GLOBAL");
        code_types_h.line("#define TYPES_H_GLOBAL");
        code_types_h.newline();
        code_types_h.line("#include \"bsatn_lib.h\" // For bsatn::Reader and bsatn::deserialize template");
        code_types_h.newline();
        code_types_h.line("// Forward declarations of all defined types and their specific deserialize functions");
        for type_def in &module.types {
            let cpp_name = to_pascal_case(&type_def.name);
            // Sum types that are just enums are `enum class`, others (structs, unions with data) are `struct`
            if matches!(&type_def.variant, TypeVariant::Sum(SumTypeDef::Enum {..})) {
                 code_types_h.line(format!("enum class {};", cpp_name));
            } else {
                 code_types_h.line(format!("struct {};", cpp_name)); // Product types and Sum-Unions are structs
            }
            // All types get a specific deserialize function declared
            code_types_h.line(format!("{} deserialize_{}(bsatn::Reader& reader);", cpp_name, cpp_name));
        }
        code_types_h.newline();
        code_types_h.line("// Includes for all type definitions (which include their serialize/deserialize_TypeName implementations)");
        for type_def in &module.types {
            code_types_h.line(format!("#include \"{}.h\"", to_snake_case(&type_def.name)));
        }
        code_types_h.newline();
        code_types_h.line("// bsatn::deserialize<T> specializations for user-defined types");
        code_types_h.line("// These connect the generic bsatn::deserialize<T> to the specific deserialize_TypeName functions.");
        code_types_h.line("namespace bsatn {");
        code_types_h.indent();
        for type_def in &module.types {
            let cpp_name = to_pascal_case(&type_def.name);
            code_types_h.line(format!("template<> inline {} deserialize<{}> (Reader& r) {{ return deserialize_{}(r); }}", cpp_name, cpp_name, cpp_name));
        }
        code_types_h.dedent();
        code_types_h.line("} // namespace bsatn");
        code_types_h.newline();
        code_types_h.line("#endif // TYPES_H_GLOBAL");
        files.push(("types.h".to_string(), code_types_h.finish()));

        // ==== tables.h ====
        code_tables_h.line("#ifndef TABLES_H_GLOBAL");
        code_tables_h.line("#define TABLES_H_GLOBAL");
        code_tables_h.newline();
        code_tables_h.line("// Forward declarations of all table classes");
        for table_def in &module.tables {
            code_tables_h.line(format!("class {}Table;", to_pascal_case(&table_def.name)));
        }
        code_tables_h.newline();
        code_tables_h.line("// Includes for all table definitions");
        for table_def in &module.tables {
            code_tables_h.line(format!("#include \"{}_table.h\"", to_snake_case(&table_def.name)));
        }
        code_tables_h.newline();
        code_tables_h.line("#endif // TABLES_H_GLOBAL");
        files.push(("tables.h".to_string(), code_tables_h.finish()));

        // ==== reducers.h ====
        code_reducers_h.line("#ifndef REDUCERS_H_GLOBAL");
        code_reducers_h.line("#define REDUCERS_H_GLOBAL");
        code_reducers_h.newline();
        code_reducers_h.line("// Includes for all reducer function headers");
        for reducer_def in &module.reducers {
            code_reducers_h.line(format!("#include \"{}_reducer.h\"", to_snake_case(&reducer_def.name)));
        }
        code_reducers_h.newline();
        code_reducers_h.line("#endif // REDUCERS_H_GLOBAL");
        files.push(("reducers.h".to_string(), code_reducers_h.finish()));


        // ==== spacetime_sdk.h ====
        code_sdk_h.line("#ifndef SPACETIME_SDK_H");
        code_sdk_h.line("#define SPACETIME_SDK_H");
        code_sdk_h.newline();
        code_sdk_h.line("#include <string>");
        code_sdk_h.line("#include <vector>");
        code_sdk_h.line("#include <functional>");
        code_sdk_h.line("#include <future>");
        code_sdk_h.line("#include <optional>");
        code_sdk_h.line("#include <map>"); // For client's table map
        code_sdk_h.line("#include <memory>"); // For std::unique_ptr, std::make_unique
        code_sdk_h.line("#include <stdexcept>"); // For runtime_error
        code_sdk_h.newline();
        code_sdk_h.line("#include \"bsatn_lib.h\"");
        code_sdk_h.line("#include \"spacetime_sdk_common.h\"");
        code_sdk_h.line("#include \"types.h\"");
        code_sdk_h.line("#include \"tables.h\"");
        code_sdk_h.line("#include \"reducers.h\"");
        code_sdk_h.newline();
        code_sdk_h.line("namespace SpacetimeDB {");
        code_sdk_h.indent();
        code_sdk_h.line("class SpacetimeDBClient {");
        code_sdk_h.line("public:");
        code_sdk_h.indent();
        code_sdk_h.line("SpacetimeDBClient(const std::string& host, const std::string& db_name, const std::string& credentials);");
        code_sdk_h.line("~SpacetimeDBClient();");
        code_sdk_h.newline();
        code_sdk_h.line("void connect();");
        code_sdk_h.line("void disconnect();");
        code_sdk_h.line("void tick(); // Main loop tick for processing events");
        code_sdk_h.newline();
        code_sdk_h.line("// Access to table instances");
        for table_def in &module.tables {
            let table_class_name = format!("{}Table", to_pascal_case(&table_def.name));
            let table_var_name = to_snake_case(&table_def.name);
            code_sdk_h.line(format!("{} {};", table_class_name, table_var_name));
        }
        code_sdk_h.newline();
        code_sdk_h.line("static SpacetimeDBClient& instance(); // Singleton accessor");
        code_sdk_h.newline();
        code_sdk_h.line("void call_reducer_internal(const std::string& reducer_name, std::vector<std::byte> payload);");
        code_sdk_h.dedent();
        code_sdk_h.line("private:");
        code_sdk_h.indent();
        code_sdk_h.line("// Internal implementation details (e.g., websocket client, event queues)");
        code_sdk_h.line("struct Impl;");
        code_sdk_h.line("std::unique_ptr<Impl> pimpl;");
        code_sdk_h.line("static SpacetimeDBClient* g_instance; // Global instance pointer for singleton");
        code_sdk_h.line("std::string m_host, m_db_name, m_credentials;");
        code_sdk_h.line("bool m_is_connected = false;");
        code_sdk_h.line("// Add other necessary members like connection objects, thread for tick, etc.");
        code_sdk_h.line("// std::unique_ptr<YourWebSocketClient> ws_client; // Example for pimpl");
        code_sdk_h.dedent();
        code_sdk_h.line("};");
        code_sdk_h.newline();
        code_sdk_h.line("// Basic singleton implementation (definitions would typically be in a .cpp file for larger projects)");
        code_sdk_h.line("inline SpacetimeDBClient* SpacetimeDBClient::g_instance = nullptr;");
        code_sdk_h.newline();
        code_sdk_h.line("inline SpacetimeDBClient& SpacetimeDBClient::instance() {");
        code_sdk_h.indent();
        code_sdk_h.line("if (!g_instance) {");
        code_sdk_h.indent();
        code_sdk_h.line("// Default initialization or error if not manually created. For robust SDK, manual init is better.");
        code_sdk_h.line("throw std::runtime_error(\"SpacetimeDBClient instance not initialized. Please create a SpacetimeDBClient object first.\");");
        code_sdk_h.dedent();
        code_sdk_h.line("}");
        code_sdk_h.line("return *g_instance;");
        code_sdk_h.dedent();
        code_sdk_h.line("}");
        code_sdk_h.newline();
        code_sdk_h.line("inline SpacetimeDBClient::SpacetimeDBClient(const std::string& host, const std::string& db_name, const std::string& credentials) :");
        code_sdk_h.line("  m_host(host), m_db_name(db_name), m_credentials(credentials), pimpl(nullptr) { // pimpl typically involves std::make_unique in body or an Impl constructor")
        code_sdk_h.indent();
        code_sdk_h.line("if (g_instance) {");
        code_sdk_h.indent();
        code_sdk_h.line("throw std::runtime_error(\"SpacetimeDBClient singleton already instantiated. Do not create multiple instances.\");");
        code_sdk_h.dedent();
        code_sdk_h.line("}");
        code_sdk_h.line("g_instance = this;");
        code_sdk_h.line("// TODO: Initialize pimpl, e.g., pimpl = std::make_unique<Impl>();");
        code_sdk_h.line("// TODO: Initialize table instances. This might involve passing a reference to self (client) to tables, or tables access client via singleton.");
        // Example of initializing tables if they need a client reference.
        // for table_def in &module.tables {
        //     let table_var_name = to_snake_case(&table_def.name);
        //     code_sdk_h.line(format!("// {} = {}Table(this); // If table needs client ptr", table_var_name, to_pascal_case(&table_def.name)));
        // }
        code_sdk_h.dedent();
        code_sdk_h.line("}");
        code_sdk_h.newline();
        code_sdk_h.line("inline SpacetimeDBClient::~SpacetimeDBClient() {");
        code_sdk_h.indent();
        code_sdk_h.line("if (m_is_connected) { disconnect(); }");
        code_sdk_h.line("g_instance = nullptr;");
        code_sdk_h.dedent();
        code_sdk_h.line("}");
        code_sdk_h.newline();
        code_sdk_h.line("inline void SpacetimeDBClient::connect() {");
        code_sdk_h.indent();
        code_sdk_h.line("// TODO: Implement connection logic (e.g., WebSocket connect using pimpl->connect(...)).");
        code_sdk_h.line("m_is_connected = true;");
        code_sdk_h.line("std::cout << \"SpacetimeDBClient: Connecting to \" << m_host << \" db: \" << m_db_name << std::endl; // Placeholder");
        code_sdk_h.dedent();
        code_sdk_h.line("}");
        code_sdk_h.newline();
        code_sdk_h.line("inline void SpacetimeDBClient::disconnect() {");
        code_sdk_h.indent();
        code_sdk_h.line("// TODO: Implement disconnection logic (e.g., pimpl->disconnect()).");
        code_sdk_h.line("m_is_connected = false;");
        code_sdk_h.line("std::cout << \"SpacetimeDBClient: Disconnected.\" << std::endl; // Placeholder");
        code_sdk_h.dedent();
        code_sdk_h.line("}");
        code_sdk_h.newline();
        code_sdk_h.line("inline void SpacetimeDBClient::tick() {");
        code_sdk_h.indent();
        code_sdk_h.line("if (!m_is_connected) return;");
        code_sdk_h.line("// TODO: Implement message processing, event dispatching, callback invocation (e.g., pimpl->process_incoming_messages()).");
        code_sdk_h.dedent();
        code_sdk_h.line("}");
        code_sdk_h.newline();
        code_sdk_h.line("inline void SpacetimeDBClient::call_reducer_internal(const std::string& reducer_name, std::vector<std::byte> payload) {");
        code_sdk_h.indent();
        code_sdk_h.line("if (!m_is_connected) {");
        code_sdk_h.indent();
        code_sdk_h.line("throw std::runtime_error(\"Client not connected when calling reducer: \" + reducer_name);");
        code_sdk_h.dedent();
        code_sdk_h.line("}");
        code_sdk_h.line("// TODO: Send reducer call over network (e.g., via pimpl->send_reducer_call(reducer_name, payload);)");
        code_sdk_h.line("std::cout << \"SpacetimeDBClient: Calling reducer '\" << reducer_name << \"' with \" << payload.size() << \" bytes.\" << std::endl; // Placeholder");
        code_sdk_h.line("(void)reducer_name; (void)payload; // Suppress unused parameter warnings for now if not using them in placeholder");
        code_sdk_h.dedent();
        code_sdk_h.line("}");
        code_sdk_h.dedent();
        code_sdk_h.line("} // namespace SpacetimeDB");
        code_sdk_h.newline();
        // Add iostream include for placeholder cout messages
        code_sdk_h.line("#include <iostream> // Included for placeholder messages in connect/call_reducer_internal etc.");
        code_sdk_h.newline();
        code_sdk_h.line("#endif // SPACETIME_SDK_H");
        files.push(("spacetime_sdk.h".to_string(), code_sdk_h.finish()));

        files
    }
}

// CodeIndenter is assumed to be available from `crate::CodeIndenter`.
// The actual definition has been removed from here.
