# --- spacetimedb_sdk_types.h ---
#ifndef SPACETIMEDB_SDK_TYPES_H
#define SPACETIMEDB_SDK_TYPES_H

#include <cstdint>
#include <vector>
#include <string>
#include <array>
#include <chrono>    // For Timestamp::current()
#include <stdexcept> // For std::runtime_error in Identity deserialization
#include <iosfwd>    // For ostream forward declaration (optional, for potential logging/debug)

// Forward declarations from bsatn.h - needed for BsatnSerializable usage
namespace spacetimedb {
namespace bsatn {
class bsatn_writer;
class bsatn_reader;
class BsatnSerializable; // Ensure BsatnSerializable itself is forward-declared or included if it's a base
} // namespace bsatn
} // namespace spacetimedb


namespace spacetimedb {
namespace sdk {

const size_t IDENTITY_SIZE = 32;

class Identity {
public:
    Identity();
    explicit Identity(const std::array<uint8_t, IDENTITY_SIZE>& bytes);
    // static Identity from_hex_string(const std::string& hex_str); // Implementation can be added if needed

    const std::array<uint8_t, IDENTITY_SIZE>& get_bytes() const;
    std::string to_hex_string() const;

    bool operator==(const Identity& other) const;
    bool operator!=(const Identity& other) const;
    bool operator<(const Identity& other) const; // For std::map keys

    // BSATN Serialization methods (duck-typed, or inherit BsatnSerializable)
    void bsatn_serialize(bsatn::bsatn_writer& writer) const;
    void bsatn_deserialize(bsatn::bsatn_reader& reader);

private:
    std::array<uint8_t, IDENTITY_SIZE> value;
};

class Timestamp {
public:
    Timestamp();
    explicit Timestamp(uint64_t milliseconds_since_epoch);

    uint64_t as_milliseconds() const;

    static Timestamp current();

    bool operator==(const Timestamp& other) const;
    bool operator!=(const Timestamp& other) const;
    bool operator<(const Timestamp& other) const;
    bool operator<=(const Timestamp& other) const;
    bool operator>(const Timestamp& other) const;
    bool operator>=(const Timestamp& other) const;

    // BSATN Serialization methods
    void bsatn_serialize(bsatn::bsatn_writer& writer) const;
    void bsatn_deserialize(bsatn::bsatn_reader& reader);

private:
    uint64_t ms_since_epoch;
};

} // namespace sdk
} // namespace spacetimedb

#endif // SPACETIMEDB_SDK_TYPES_H

# --- spacetimedb_sdk_types.cpp ---
#include "spacetimedb_sdk_types.h"
#include "bsatn.h" // For bsatn_writer, bsatn_reader
#include <iomanip>  // For std::setw, std::setfill with to_hex_string
#include <sstream>  // For std::ostringstream with to_hex_string
#include <algorithm> // for std::copy
#include <stdexcept> // For std::runtime_error

namespace spacetimedb {
namespace sdk {

// Identity Implementation
Identity::Identity() {
    value.fill(0);
}

Identity::Identity(const std::array<uint8_t, IDENTITY_SIZE>& bytes) : value(bytes) {}

const std::array<uint8_t, IDENTITY_SIZE>& Identity::get_bytes() const {
    return value;
}

std::string Identity::to_hex_string() const {
    std::ostringstream oss;
    oss << std::hex << std::setfill('0');
    for (uint8_t byte : value) {
        oss << std::setw(2) << static_cast<int>(byte);
    }
    return oss.str();
}

bool Identity::operator==(const Identity& other) const {
    return value == other.value;
}

bool Identity::operator!=(const Identity& other) const {
    return value != other.value;
}

bool Identity::operator<(const Identity& other) const {
    // Lexicographical comparison for std::map ordering
    return std::lexicographical_compare(value.begin(), value.end(),
                                        other.value.begin(), other.value.end());
}

void Identity::bsatn_serialize(bsatn::bsatn_writer& writer) const {
    // Serialize as a length-prefixed byte array
    std::vector<uint8_t> bytes_vec(value.begin(), value.end());
    writer.write_bytes(bytes_vec);
}

void Identity::bsatn_deserialize(bsatn::bsatn_reader& reader) {
    std::vector<uint8_t> bytes_vec = reader.read_bytes();
    if (bytes_vec.size() != IDENTITY_SIZE) {
        throw std::runtime_error("BSATN deserialization error: Identity size mismatch. Expected " +
                                 std::to_string(IDENTITY_SIZE) + ", got " + std::to_string(bytes_vec.size()));
    }
    std::copy(bytes_vec.begin(), bytes_vec.end(), value.begin());
}

// Timestamp Implementation
Timestamp::Timestamp() : ms_since_epoch(0) {}

Timestamp::Timestamp(uint64_t milliseconds_since_epoch) : ms_since_epoch(milliseconds_since_epoch) {}

uint64_t Timestamp::as_milliseconds() const {
    return ms_since_epoch;
}

Timestamp Timestamp::current() {
    auto now = std::chrono::system_clock::now();
    auto duration = now.time_since_epoch();
    return Timestamp(static_cast<uint64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(duration).count()));
}

bool Timestamp::operator==(const Timestamp& other) const {
    return ms_since_epoch == other.ms_since_epoch;
}

bool Timestamp::operator!=(const Timestamp& other) const {
    return ms_since_epoch != other.ms_since_epoch;
}

bool Timestamp::operator<(const Timestamp& other) const {
    return ms_since_epoch < other.ms_since_epoch;
}

bool Timestamp::operator<=(const Timestamp& other) const {
    return ms_since_epoch <= other.ms_since_epoch;
}

bool Timestamp::operator>(const Timestamp& other) const {
    return ms_since_epoch > other.ms_since_epoch;
}

bool Timestamp::operator>=(const Timestamp& other) const {
    return ms_since_epoch >= other.ms_since_epoch;
}

void Timestamp::bsatn_serialize(bsatn::bsatn_writer& writer) const {
    writer.write_u64(ms_since_epoch);
}

void Timestamp::bsatn_deserialize(bsatn::bsatn_reader& reader) {
    ms_since_epoch = reader.read_u64();
}

} // namespace sdk
} // namespace spacetimedb

# --- reducer_context.h ---
#ifndef REDUCER_CONTEXT_H
#define REDUCER_CONTEXT_H

#include "spacetimedb_sdk_types.h" // For Identity, Timestamp

namespace spacetimedb {
namespace sdk {

// Forward declaration
class Database;

class ReducerContext {
public:
    ReducerContext(Identity sender, Timestamp timestamp, Database& db_instance);

    const Identity& get_sender() const;
    Timestamp get_timestamp() const;
    Database& db();
    const Database& db() const; // Const overload

private:
    Identity current_sender;
    Timestamp current_timestamp;
    Database& database_instance;
};

} // namespace sdk
} // namespace spacetimedb

#endif // REDUCER_CONTEXT_H

# --- reducer_context.cpp ---
#include "reducer_context.h"
#include "database.h" // Required for the Database& member

namespace spacetimedb {
namespace sdk {

ReducerContext::ReducerContext(Identity sender, Timestamp timestamp, Database& db_instance)
    : current_sender(std::move(sender)),
      current_timestamp(timestamp),
      database_instance(db_instance) {}

const Identity& ReducerContext::get_sender() const {
    return current_sender;
}

Timestamp ReducerContext::get_timestamp() const {
    return current_timestamp;
}

Database& ReducerContext::db() {
    return database_instance;
}

const Database& ReducerContext::db() const {
    return database_instance;
}

} // namespace sdk
} // namespace spacetimedb

# --- database.h ---
#ifndef SPACETIMEDB_SDK_DATABASE_H
#define SPACETIMEDB_SDK_DATABASE_H

#include <string>
#include <stdexcept> // For std::runtime_error
#include "table.h" // For Table<T>
#include "spacetimedb_abi.h" // For ABI function calls
#include "bsatn.h" // For BsatnSerializable concept (implicitly via Table<T>)

namespace spacetimedb {
namespace sdk {

class Database {
public:
    Database();

    template<typename T>
    Table<T> get_table(const std::string& table_name) {
        uint32_t table_id = 0;
        // ABI: uint16_t _get_table_id(const uint8_t *name_ptr, size_t name_len, uint32_t *out_table_id_ptr)
        uint16_t error_code = _get_table_id(
            reinterpret_cast<const uint8_t*>(table_name.c_str()),
            table_name.length(),
            &table_id
        );

        if (error_code != 0) {
            throw std::runtime_error("Database::get_table: _get_table_id ABI call failed for table '" +
                                     table_name + "' with error code " + std::to_string(error_code));
        }

        // It's possible that an error_code of 0 still means "not found" if table_id is a sentinel like 0.
        // This depends on the ABI contract for _get_table_id. Assuming 0 is an invalid ID if no error.
        if (table_id == 0 && error_code == 0) {
            throw std::runtime_error("Table not found: " + table_name + " (table_id resolved to 0 without ABI error)");
        }

        return Table<T>(table_id);
    }
};

} // namespace sdk
} // namespace spacetimedb

#endif // SPACETIMEDB_SDK_DATABASE_H

# --- database.cpp ---
#include "database.h"
// spacetimedb_abi.h is included via database.h -> table.h -> spacetimedb_abi.h

namespace spacetimedb {
namespace sdk {

Database::Database() {
    // Constructor for Database.
    // If the Database class needed to initialize any state or acquire resources
    // via ABI calls at construction time, it would happen here.
}

// Template methods like get_table<T>() are fully defined in database.h

} // namespace sdk
} // namespace spacetimedb

# --- table.h ---
#ifndef SPACETIMEDB_SDK_TABLE_H
#define SPACETIMEDB_SDK_TABLE_H

#include "spacetimedb_sdk_types.h"
#include "bsatn.h"
#include "spacetimedb_abi.h" // For ABI function calls

#include <string>
#include <vector>
#include <stdexcept> // For std::runtime_error
#include <memory>    // For std::unique_ptr (not currently used, but often useful in iterators)

namespace spacetimedb {
namespace sdk {

template<typename T>
class TableIterator {
public:
    using iterator_category = std::input_iterator_tag;
    using value_type = T;
    using difference_type = std::ptrdiff_t;
    using pointer = T*;
    using reference = T&;

    TableIterator() : iter_handle_(0), is_valid_(false) {}

    explicit TableIterator(BufferIter iter_handle)
        : iter_handle_(iter_handle), is_valid_(false) {
        if (iter_handle_ != 0) {
            advance();
        }
    }

    TableIterator(const TableIterator& other) = delete;
    TableIterator& operator=(const TableIterator& other) = delete;

    TableIterator(TableIterator&& other) noexcept
        : iter_handle_(other.iter_handle_),
          current_row_(std::move(other.current_row_)),
          is_valid_(other.is_valid_) {
        other.iter_handle_ = 0;
        other.is_valid_ = false;
    }

    TableIterator& operator=(TableIterator&& other) noexcept {
        if (this != &other) {
            if (iter_handle_ != 0) {
                 uint16_t drop_ec = _iter_drop(iter_handle_);
                 // Optionally log drop_ec if not 0
            }
            iter_handle_ = other.iter_handle_;
            current_row_ = std::move(other.current_row_);
            is_valid_ = other.is_valid_;
            other.iter_handle_ = 0;
            other.is_valid_ = false;
        }
        return *this;
    }

    ~TableIterator() {
        if (iter_handle_ != 0) {
            _iter_drop(iter_handle_); // Error code ignored in destructor
            iter_handle_ = 0;
        }
    }

    const T& operator*() const {
        if (!is_valid_) {
            throw std::out_of_range("Dereferencing invalid or end TableIterator");
        }
        return current_row_;
    }

    const T* operator->() const {
        if (!is_valid_) {
            throw std::out_of_range("Dereferencing invalid or end TableIterator");
        }
        return &current_row_;
    }

    TableIterator& operator++() {
        if (!is_valid_) {
             throw std::out_of_range("Incrementing invalid or end TableIterator");
        }
        advance();
        return *this;
    }

    bool operator!=(const TableIterator& other) const {
        return is_valid_ != other.is_valid_;
    }

    bool operator==(const TableIterator& other) const {
        return is_valid_ == other.is_valid_;
    }

private:
    void advance() {
        if (iter_handle_ == 0) {
            is_valid_ = false;
            return;
        }

        Buffer row_data_buffer_handle = 0;
        uint16_t error_code = _iter_next(iter_handle_, &row_data_buffer_handle);

        if (error_code != 0) {
            is_valid_ = false;
            throw std::runtime_error("TableIterator: _iter_next failed with code " + std::to_string(error_code));
        }

        if (row_data_buffer_handle == 0) { // Standard way to signal end of iteration
            is_valid_ = false;
            // Iteration finished, iter_handle_ will be dropped by destructor or move op
            return;
        }

        size_t len = _buffer_len(row_data_buffer_handle);
        std::vector<uint8_t> temp_buffer(len); // Handles len = 0 correctly

        uint16_t consume_error_code = _buffer_consume(row_data_buffer_handle, temp_buffer.data(), len);
        // Note: _buffer_consume implies the buffer handle `row_data_buffer_handle` is now invalid.

        if (consume_error_code != 0) {
            is_valid_ = false;
            throw std::runtime_error("TableIterator: _buffer_consume failed with code " + std::to_string(consume_error_code));
        }

        try {
            bsatn::bsatn_reader reader(temp_buffer.data(), temp_buffer.size());
            current_row_.bsatn_deserialize(reader);
            is_valid_ = true;
        } catch (const std::exception& e) {
            is_valid_ = false;
            throw std::runtime_error(std::string("TableIterator: BSATN deserialization failed: ") + e.what());
        }
    }

    BufferIter iter_handle_;
    T current_row_;
    bool is_valid_;
};


template<typename T>
class Table {
public:
    explicit Table(uint32_t table_id) : table_id_(table_id) {
        static_assert(std::is_base_of_v<bsatn::BsatnSerializable, T> ||
                      (requires(T& t, bsatn::bsatn_writer& w) { t.bsatn_serialize(w); } &&
                       requires(T& t, bsatn::bsatn_reader& r) { t.bsatn_deserialize(r); }),
                      "Table type T must implement BsatnSerializable or provide bsatn_serialize/bsatn_deserialize methods.");
    }

    void insert(T& row_data) {
        bsatn::bsatn_writer writer;
        row_data.bsatn_serialize(writer);

        std::vector<uint8_t> buffer_vec = writer.move_buffer();

        uint16_t error_code = _insert(table_id_, buffer_vec.data(), buffer_vec.size());

        if (error_code != 0) {
            throw std::runtime_error("Table::insert: _insert ABI call failed with code " + std::to_string(error_code));
        }

        try {
            bsatn::bsatn_reader reader(buffer_vec.data(), buffer_vec.size());
            row_data.bsatn_deserialize(reader);
        } catch (const std::exception& e) {
            throw std::runtime_error(std::string("Table::insert: BSATN deserialization after insert failed: ") + e.what());
        }
    }

    template<typename ValueType>
    uint32_t delete_by_col_eq(uint32_t column_index, const ValueType& value_to_match) {
        static_assert(
            (std::is_arithmetic_v<ValueType> || std::is_same_v<ValueType, bool> || std::is_same_v<ValueType, std::string>) ||
            (std::is_base_of_v<bsatn::BsatnSerializable, ValueType> || requires(const ValueType& v, bsatn::bsatn_writer& w) { v.bsatn_serialize(w); }),
            "ValueType for delete_by_col_eq must be a supported primitive, std::string, or implement bsatn_serialize."
        );

        bsatn::bsatn_writer writer;
        if constexpr (std::is_same_v<ValueType, bool>) writer.write_bool(value_to_match);
        else if constexpr (std::is_same_v<ValueType, uint8_t>) writer.write_u8(value_to_match);
        else if constexpr (std::is_same_v<ValueType, uint16_t>) writer.write_u16(value_to_match);
        else if constexpr (std::is_same_v<ValueType, uint32_t>) writer.write_u32(value_to_match);
        else if constexpr (std::is_same_v<ValueType, uint64_t>) writer.write_u64(value_to_match);
        else if constexpr (std::is_same_v<ValueType, int8_t>) writer.write_i8(value_to_match);
        else if constexpr (std::is_same_v<ValueType, int16_t>) writer.write_i16(value_to_match);
        else if constexpr (std::is_same_v<ValueType, int32_t>) writer.write_i32(value_to_match);
        else if constexpr (std::is_same_v<ValueType, int64_t>) writer.write_i64(value_to_match);
        else if constexpr (std::is_same_v<ValueType, float>) writer.write_f32(value_to_match);
        else if constexpr (std::is_same_v<ValueType, double>) writer.write_f64(value_to_match);
        else if constexpr (std::is_same_v<ValueType, std::string>) writer.write_string(value_to_match);
        else {
            value_to_match.bsatn_serialize(writer);
        }

        std::vector<uint8_t> value_buffer_vec = writer.move_buffer();
        uint32_t deleted_count = 0;

        uint16_t error_code = _delete_by_col_eq(table_id_, column_index, value_buffer_vec.data(), value_buffer_vec.size(), &deleted_count);

        if (error_code != 0) {
            throw std::runtime_error("Table::delete_by_col_eq: _delete_by_col_eq ABI call failed with code " + std::to_string(error_code));
        }
        return deleted_count;
    }

    TableIterator<T> iter() {
        BufferIter iter_handle = 0;
        uint16_t error_code = _iter_start(table_id_, &iter_handle);
        if (error_code != 0) {
            throw std::runtime_error("Table::iter: _iter_start ABI call failed with code " + std::to_string(error_code));
        }
        return TableIterator<T>(iter_handle);
    }

    template<typename ValueType>
    std::vector<T> find_by_col_eq(uint32_t column_index, const ValueType& value_to_match) {
         static_assert(
            (std::is_arithmetic_v<ValueType> || std::is_same_v<ValueType, bool> || std::is_same_v<ValueType, std::string>) ||
            (std::is_base_of_v<bsatn::BsatnSerializable, ValueType> || requires(const ValueType& v, bsatn::bsatn_writer& w) { v.bsatn_serialize(w); }),
            "ValueType for find_by_col_eq must be a supported primitive, std::string, or implement bsatn_serialize."
        );

        bsatn::bsatn_writer writer;
        if constexpr (std::is_same_v<ValueType, bool>) writer.write_bool(value_to_match);
        else if constexpr (std::is_same_v<ValueType, uint8_t>) writer.write_u8(value_to_match);
        else if constexpr (std::is_same_v<ValueType, uint16_t>) writer.write_u16(value_to_match);
        else if constexpr (std::is_same_v<ValueType, uint32_t>) writer.write_u32(value_to_match);
        else if constexpr (std::is_same_v<ValueType, uint64_t>) writer.write_u64(value_to_match);
        else if constexpr (std::is_same_v<ValueType, int8_t>) writer.write_i8(value_to_match);
        else if constexpr (std::is_same_v<ValueType, int16_t>) writer.write_i16(value_to_match);
        else if constexpr (std::is_same_v<ValueType, int32_t>) writer.write_i32(value_to_match);
        else if constexpr (std::is_same_v<ValueType, int64_t>) writer.write_i64(value_to_match);
        else if constexpr (std::is_same_v<ValueType, float>) writer.write_f32(value_to_match);
        else if constexpr (std::is_same_v<ValueType, double>) writer.write_f64(value_to_match);
        else if constexpr (std::is_same_v<ValueType, std::string>) writer.write_string(value_to_match);
        else {
            value_to_match.bsatn_serialize(writer);
        }

        std::vector<uint8_t> value_buffer_vec = writer.move_buffer();
        Buffer result_buffer_handle = 0;

        uint16_t error_code = _iter_by_col_eq(table_id_, column_index, value_buffer_vec.data(), value_buffer_vec.size(), &result_buffer_handle);

        if (error_code != 0) {
            throw std::runtime_error("Table::find_by_col_eq: _iter_by_col_eq ABI call failed with code " + std::to_string(error_code));
        }

        std::vector<T> results;
        if (result_buffer_handle == 0) {
            return results; // No error, but no results buffer (e.g. not found or empty)
        }

        size_t len = _buffer_len(result_buffer_handle);
        std::vector<uint8_t> concatenated_rows_buffer(len); // Handles len = 0

        uint16_t consume_error_code = _buffer_consume(result_buffer_handle, concatenated_rows_buffer.data(), len);
        // result_buffer_handle is now invalid after consumption

        if (consume_error_code != 0) {
            throw std::runtime_error("Table::find_by_col_eq: _buffer_consume failed with code " + std::to_string(consume_error_code));
        }

        if (len > 0) {
            bsatn::bsatn_reader reader(concatenated_rows_buffer.data(), concatenated_rows_buffer.size());
            try {
                while(!reader.eof()) {
                    T row_data;
                    row_data.bsatn_deserialize(reader);
                    results.push_back(std::move(row_data));
                }
            } catch (const std::exception& e) {
                throw std::runtime_error(std::string("Table::find_by_col_eq: BSATN deserialization of concatenated rows failed: ") + e.what());
            }
        }
        return results;
    }

private:
    uint32_t table_id_;
};

} // namespace sdk
} // namespace spacetimedb

#endif // SPACETIMEDB_SDK_TABLE_H

# --- spacetimedb_sdk_reducer.h ---
#ifndef SPACETIMEDB_SDK_REDUCER_H
#define SPACETIMEDB_SDK_REDUCER_H

#include "spacetimedb_sdk_types.h"
#include "reducer_context.h"
#include "database.h"
#include "bsatn.h"
#include "spacetimedb_abi.h"

#include <string>
#include <vector>
#include <tuple>
#include <utility>
#include <memory>
#include <cstring> // For std::strlen (used in macro for error messages)

namespace spacetimedb {
namespace sdk {

// Global database instance for reducers
// Needs to be initialized by the host calling _spacetimedb_sdk_init
static std::unique_ptr<Database> global_db_instance_ptr_for_reducers;

inline void initialize_reducer_database_instance() {
    if (!global_db_instance_ptr_for_reducers) {
        global_db_instance_ptr_for_reducers = std::make_unique<Database>();
    }
}

// Exported init function for host to call
extern "C" __attribute__((export_name("_spacetimedb_sdk_init")))
void _spacetimedb_sdk_init() {
    initialize_reducer_database_instance();
}


// Template helper to deserialize a single argument
template<typename T>
T deserialize_reducer_arg(bsatn::bsatn_reader& reader) {
    T arg;
    if constexpr (std::is_same_v<T, bool>) return reader.read_bool();
    else if constexpr (std::is_same_v<T, uint8_t>) return reader.read_u8();
    else if constexpr (std::is_same_v<T, uint16_t>) return reader.read_u16();
    else if constexpr (std::is_same_v<T, uint32_t>) return reader.read_u32();
    else if constexpr (std::is_same_v<T, uint64_t>) return reader.read_u64();
    else if constexpr (std::is_same_v<T, int8_t>) return reader.read_i8();
    else if constexpr (std::is_same_v<T, int16_t>) return reader.read_i16();
    else if constexpr (std::is_same_v<T, int32_t>) return reader.read_i32();
    else if constexpr (std::is_same_v<T, int64_t>) return reader.read_i64();
    else if constexpr (std::is_same_v<T, float>) return reader.read_f32();
    else if constexpr (std::is_same_v<T, double>) return reader.read_f64();
    else if constexpr (std::is_same_v<T, std::string>) return reader.read_string();
    else if constexpr (std::is_same_v<T, std::vector<uint8_t>>) return reader.read_bytes();
    else if constexpr (std::is_same_v<T, Identity>) { // Explicitly handle SDK types
        arg.bsatn_deserialize(reader); return arg;
    } else if constexpr (std::is_same_v<T, Timestamp>) { // Explicitly handle SDK types
        arg.bsatn_deserialize(reader); return arg;
    }
    // Check for BsatnSerializable or duck-typed method last
    else if constexpr (std::is_base_of_v<bsatn::BsatnSerializable, T> ||
                       requires(T& t, bsatn::bsatn_reader& r) { t.bsatn_deserialize(r); }) {
        arg.bsatn_deserialize(reader);
        return arg;
    } else {
        static_assert(std::is_void_v<T>, "Unsupported reducer argument type for BSATN deserialization.");
        return T{};
    }
}

// Helper to deserialize all arguments into a tuple
template<typename... Args, std::size_t... Is>
std::tuple<Args...> deserialize_all_args_impl(bsatn::bsatn_reader& reader, std::index_sequence<Is...>) {
    return std::make_tuple(deserialize_reducer_arg<std::remove_cv_t<std::remove_reference_t<std::tuple_element_t<Is, std::tuple<Args...>>>>>(reader)...);
}

template<typename... Args>
std::tuple<Args...> deserialize_all_args(bsatn::bsatn_reader& reader) {
    return deserialize_all_args_impl<Args...>(reader, std::index_sequence_for<Args...>{});
}

// Macro to define and register a reducer
#define SPACETIMEDB_REDUCER(REDUCER_FUNC_NAME, ...) \
    extern void REDUCER_FUNC_NAME(spacetimedb::sdk::ReducerContext& ctx, ##__VA_ARGS__); \
    extern "C" __attribute__((export_name(#REDUCER_FUNC_NAME))) \
    uint16_t _spacetimedb_reducer_wrapper_##REDUCER_FUNC_NAME(const uint8_t* args_data, size_t args_len) { \
        if (!spacetimedb::sdk::global_db_instance_ptr_for_reducers) { \
            const char* err_msg = "Critical Error: SDK Database not initialized before calling reducer " #REDUCER_FUNC_NAME ". Host must call _spacetimedb_sdk_init."; \
            _console_log(0 /*FATAL like level*/, nullptr, 0, reinterpret_cast<const uint8_t*>(err_msg), std::strlen(err_msg)); \
            return 100; /* Distinct error code for uninitialized SDK */ \
        } \
        try { \
            spacetimedb::bsatn::bsatn_reader reader(args_data, args_len); \
            spacetimedb::sdk::Identity sender; \
            sender.bsatn_deserialize(reader); \
            spacetimedb::sdk::Timestamp timestamp; \
            timestamp.bsatn_deserialize(reader); \
            spacetimedb::sdk::ReducerContext ctx(sender, timestamp, *spacetimedb::sdk::global_db_instance_ptr_for_reducers); \
            using UserArgsTuple = std::tuple<__VA_ARGS__>; \
            if constexpr (std::tuple_size_v<UserArgsTuple> > 0) { \
                auto deserialized_args_tuple = spacetimedb::sdk::deserialize_all_args<__VA_ARGS__>(reader); \
                std::apply([&](auto&&... args) { \
                    REDUCER_FUNC_NAME(ctx, std::forward<decltype(args)>(args)...); \
                }, std::move(deserialized_args_tuple)); \
            } else { \
                 REDUCER_FUNC_NAME(ctx); \
            } \
            return 0; /* Success */ \
        } catch (const std::exception& e) { \
            std::string error_message = "Reducer '" #REDUCER_FUNC_NAME "' C++ exception: "; \
            error_message += e.what(); \
            if (error_message.length() > 250) { error_message.resize(250); error_message += "..."; } \
            _console_log(3 /*ERROR level*/, nullptr, 0, reinterpret_cast<const uint8_t*>(error_message.c_str()), error_message.length()); \
            return 1; /* General error code for C++ exception */ \
        } catch (...) { \
            std::string error_message = "Reducer '" #REDUCER_FUNC_NAME "' unknown C++ exception."; \
             _console_log(3 /*ERROR level*/, nullptr, 0, reinterpret_cast<const uint8_t*>(error_message.c_str()), error_message.length()); \
            return 2; /* Specific error code for unknown C++ exception */ \
        } \
    }

#define SPACETIMEDB_REDUCER_NO_ARGS(REDUCER_FUNC_NAME) \
    extern void REDUCER_FUNC_NAME(spacetimedb::sdk::ReducerContext& ctx); \
    extern "C" __attribute__((export_name(#REDUCER_FUNC_NAME))) \
    uint16_t _spacetimedb_reducer_wrapper_##REDUCER_FUNC_NAME(const uint8_t* args_data, size_t args_len) { \
        if (!spacetimedb::sdk::global_db_instance_ptr_for_reducers) { \
             const char* err_msg = "Critical Error: SDK Database not initialized before calling reducer " #REDUCER_FUNC_NAME ". Host must call _spacetimedb_sdk_init."; \
            _console_log(0 /*FATAL like level*/, nullptr, 0, reinterpret_cast<const uint8_t*>(err_msg), std::strlen(err_msg)); \
            return 100; \
        } \
        try { \
            spacetimedb::bsatn::bsatn_reader reader(args_data, args_len); \
            spacetimedb::sdk::Identity sender; \
            sender.bsatn_deserialize(reader); \
            spacetimedb::sdk::Timestamp timestamp; \
            timestamp.bsatn_deserialize(reader); \
            spacetimedb::sdk::ReducerContext ctx(sender, timestamp, *spacetimedb::sdk::global_db_instance_ptr_for_reducers); \
            REDUCER_FUNC_NAME(ctx); \
            return 0; /* Success */ \
        } catch (const std::exception& e) { \
            std::string error_message = "Reducer '" #REDUCER_FUNC_NAME "' C++ exception: "; \
            error_message += e.what(); \
            if (error_message.length() > 250) { error_message.resize(250); error_message += "..."; } \
            _console_log(3 /*ERROR level*/, nullptr, 0, reinterpret_cast<const uint8_t*>(error_message.c_str()), error_message.length()); \
            return 1; \
        } catch (...) { \
            std::string error_message = "Reducer '" #REDUCER_FUNC_NAME "' unknown C++ exception."; \
            _console_log(3 /*ERROR level*/, nullptr, 0, reinterpret_cast<const uint8_t*>(error_message.c_str()), error_message.length()); \
            return 2; \
        } \
    }

} // namespace sdk
} // namespace spacetimedb

#endif // SPACETIMEDB_SDK_REDUCER_H

# --- spacetimedb_sdk_table_registry.h ---
#ifndef SPACETIMEDB_SDK_TABLE_REGISTRY_H
#define SPACETIMEDB_SDK_TABLE_REGISTRY_H

#include <string>
#include <vector>
#include <map>
#include <stdexcept>
#include <typeinfo>
#include <algorithm>
#include <cstdint>   // For uint32_t

namespace spacetimedb {
namespace sdk {
namespace registry {

struct TableMetadata {
    std::string table_name_in_db;
    std::string cpp_type_name;
    std::string primary_key_field_name;
    uint32_t primary_key_column_index;

    TableMetadata(std::string db_name = "", std::string cpp_name = "", std::string pk_name = "", uint32_t pk_idx = static_cast<uint32_t>(-1))
        : table_name_in_db(std::move(db_name)),
          cpp_type_name(std::move(cpp_name)),
          primary_key_field_name(std::move(pk_name)),
          primary_key_column_index(pk_idx) {}
};

extern std::map<std::string, TableMetadata>& get_global_table_registry();

const TableMetadata* get_table_metadata_by_cpp_type_name(const std::string& cpp_type_name_mangled);
const TableMetadata* get_table_metadata_by_db_name(const std::string& db_table_name);
uint32_t get_pk_column_index_by_cpp_type_name(const std::string& cpp_type_name_mangled);


struct TableRegistrar {
    TableRegistrar(const char* cpp_type_name_mangled, // Use const char* from typeid().name()
                   const std::string& table_name_in_db_str,
                   const std::string& pk_field_name_str) {
        TableMetadata metadata;
        metadata.cpp_type_name = cpp_type_name_mangled;
        metadata.table_name_in_db = table_name_in_db_str;
        metadata.primary_key_field_name = pk_field_name_str;

        if (!pk_field_name_str.empty()) {
            metadata.primary_key_column_index = 0;
        } else {
            metadata.primary_key_column_index = static_cast<uint32_t>(-1);
        }

        auto& registry = get_global_table_registry();
        // Using insert to avoid overwriting if already registered, though static init should make this rare.
        registry.insert({std::string(cpp_type_name_mangled), metadata});
    }
};

} // namespace registry

#define SPACETIMEDB_REGISTER_TABLE(CppStructType, TableNameInDbString, PrimaryKeyFieldAsString) \
    namespace { \
        static spacetimedb::sdk::registry::TableRegistrar \
            registrar_instance_##CppStructType( \
                typeid(CppStructType).name(), \
                TableNameInDbString, \
                PrimaryKeyFieldAsString \
            ); \
    }

template<typename T>
const registry::TableMetadata* get_table_metadata() {
    return registry::get_table_metadata_by_cpp_type_name(typeid(T).name());
}

template<typename T>
uint32_t get_pk_column_index() {
     return registry::get_pk_column_index_by_cpp_type_name(typeid(T).name());
}

} // namespace sdk
} // namespace spacetimedb

#endif // SPACETIMEDB_SDK_TABLE_REGISTRY_H

# --- spacetimedb_sdk_table_registry.cpp ---
#include "spacetimedb_sdk_table_registry.h"
#include <map> // Ensure map is included for the definition

namespace spacetimedb {
namespace sdk {
namespace registry {

// Definition of the global table registry
// This ensures a single instance across the module.
static std::map<std::string, TableMetadata> global_registry_map_instance;

std::map<std::string, TableMetadata>& get_global_table_registry() {
    return global_registry_map_instance;
}

const TableMetadata* get_table_metadata_by_cpp_type_name(const std::string& cpp_type_name_mangled) {
    auto& registry = get_global_table_registry();
    auto it = registry.find(cpp_type_name_mangled);
    if (it != registry.end()) {
        return &it->second;
    }
    return nullptr;
}

const TableMetadata* get_table_metadata_by_db_name(const std::string& db_table_name) {
    auto& registry = get_global_table_registry();
    for (const auto& pair : registry) {
        if (pair.second.table_name_in_db == db_table_name) {
            return &pair.second;
        }
    }
    return nullptr;
}

uint32_t get_pk_column_index_by_cpp_type_name(const std::string& cpp_type_name_mangled) {
    const TableMetadata* metadata = get_table_metadata_by_cpp_type_name(cpp_type_name_mangled);
    if (metadata && !metadata->primary_key_field_name.empty()) {
        return metadata->primary_key_column_index;
    }
    return static_cast<uint32_t>(-1);
}

} // namespace registry
} // namespace sdk
} // namespace spacetimedb
