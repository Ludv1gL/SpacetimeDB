# Module and SDK API: Subscriptions

This section normatively defines the user-facing interface clients use to subscribe to queries. It supersedes the user-facing interfaces described in [0015: Subscription API](../0015-subscription-api.md) and [01: `DbConnection`](./01-db-connection.md). Internals and semantics, including the WebSocket API, are as described in [0015: Subscription API](../0015-subscription-api.md).

## Constructing subscriptions

In clients, the `DbContext` trait, interface or class is extended with a method `subscription_builder`:

```rust
pub trait DbContext {
    // Other members elided.

    /// May be generic over a lifetime, i.e. may borrow from the `DbContext`,
    /// like `type SubscriptionBuilder<'db>;`.
    type SubscriptionBuilder;

    fn subscription_builder(&self) -> Self::SubscriptionBuilder;
}
```

Users are not intended to name the `SubscriptionBuilder` type, and so it is at the implementor's discretion whether it is a concrete type defined in the module-specific codegen or a generic type defined in the SDK library. Note that the `SubscriptionBuilder` type needs access to module-specific information so that it can expose callbacks bounded on the module-specific `EventContext` type.

See [03: SDK Callbacks: The `EventContext` type](./03-sdk-callbacks.md#the-eventcontext-type) for the definition of `EventContext`.

`SubscriptionBuilder` has the following methods which allow configuring the subscription:

```rust
impl SubscriptionBuilder {
    /// Registers `callback` to run when this query is successfully added to our subscribed set,
    /// I.e. when its `SubscriptionApplied` message is received.
    ///
    /// The database state exposed via the `&EventContext` argument
    /// includes all the rows added to the client cache as a result of the new subscription.
    ///
    /// The event in the `&EventContext` argument is `Event::SubscribeApplied`.
    ///
    /// Multiple `on_applied` callbacks for the same query may coexist.
    /// No mechanism for un-registering `on_applied` callbacks is exposed.
    pub fn on_applied(self, callback: impl FnOnce(&EventContext)) -> Self;

    /// Registers `callback` to run when this query either:
    /// - Fails to be added to our subscribed set.
    /// - Is unexpectedly removed from our subscribed set.
    ///
    /// If the subscription had previously started and has been unexpectedly removed,
    /// the database state exposed via the `&EventContext` argument contains no rows
    /// from any subscriptions removed within the same error event.
    /// As proposed, it must therefore contain no rows.
    ///
    /// The event in the `&EventContext` argument is `Event::SubscribeError`,
    /// containing a dynamic error object with a human-readable description of the error
    /// for diagnostic purposes.
    ///
    /// Multiple `on_error` callbacks for the same query may coexist.
    /// No mechanism for un-registering `on_error` callbacks is exposed.
    pub fn on_error(self, callback: impl FnOnce(&EventContext)) -> Self;

    /// Issues a new `Subscribe` message,
    /// adding `query` to the client's set of subscribed queries.
    ///
    /// `query` should be a single SQL `SELECT` statement.
    ///
    /// Installs the above callbacks into the new `SubscriptionHandle`,
    /// before issuing the `Subscribe` message, to avoid race conditions.
    ///
    /// Returns an error if the connection is not active.
    ///
    /// Consumes the `SubscriptionBuilder`,
    /// because the callbacks are not necessarily `Clone`.
    pub fn subscribe(self, query_sql: &str) -> anyhow::Result<SubscriptionHandle>;
}
```

Corresponding C# API will look like following. Note that C# doesn't support associated types, so we use a generic over the module-specific `EventContext` instead.

```csharp
public class DbContext
{
    // Other members elided.

    public SubscriptionBuilder<EventContext> SubscriptionBuilder();
}

public class SubscriptionBuilder<TEventContext>
{
    public SubscriptionBuilder OnApplied(Action<TEventContext> callback);
    public SubscriptionBuilder OnError(Action<TEventContext> callback);
    public SubscriptionHandle Subscribe(string querySql);
}
```

The `SubscriptionHandle` type is autogenerated with module-specific type information, and exported from the root of the generated `module_bindings` module or namespace. `SubscriptionHandle` must be a concrete type without any lifetime generics, i.e. it may not borrow from the `DbContext`, as users are expected to stash `SubscriptionHandle`s in global or larger-scoped storage which outlasts the scope which borrows the `DbContext`.

`SubscriptionHandle` exposes the following methods:

```rust
impl SubscriptionHandle {
    /// Consumes self and issues an `Unsubscribe` message,
    /// removing this query from the client's set of subscribed queries.
    /// It is only valid to call this method if `is_active()` is `true`.
    fn unsubscribe(self) -> Result<()>;

    /// `Unsubscribe`s and also registers a callback to run upon success.
    /// I.e. when an `UnsubscribeApplied` message is received.
    ///
    /// If `Unsubscribe` returns an error,
    /// or if the `on_error` callback(s) are invoked before this subscription would end normally,
    /// the `on_end` callback is not invoked.
    fn unsubscribe_then(self, on_end: impl FnOnce(&EventContext)) -> Result<()>;

    /// True if this `SubscriptionHandle` has ended,
    /// either due to an error or a call to `unsubscribe`.
    ///
    /// This is initially false, and becomes true when either the `on_end` or `on_error` callback is invoked.
    /// A subscription which has not yet been applied is not active, but is also not ended.
    fn is_ended(&self) -> bool;

    /// True if this `SubscriptionHandle` is active, meaning it has been successfully applied
    /// and has not since ended, either due to an error or a complete `unsubscribe` request-response pair.
    ///
    /// This corresponds exactly to the interval bounded at the start by the `on_applied` callback
    /// and at the end by either the `on_end` or `on_error` callback.
    fn is_active(&self) -> bool;
}
```

Corresponding C# API will look like this:

```csharp
public class SubscriptionHandle
{
    public void Unsuscribe();
    public void UnsuscribeThen(Action<EventContext> onEnd);
    public bool IsEnded { get; }
    public bool IsActive { get; }
}
```

Dropping (or, in C#, `Dispose()`-ing) a `SubscriptionHandle` has no special behavior. If a `SubscriptionHandle` which `is_active` or not `is_ended` is dropped or becomes inaccessible before calling `unsubscribe`, the client remains subscribed to that query until either the client disconnects or an error in incremental eval causes all subscriptions to end. We expect a significant class of clients to use subscriptions in this "fire-and-forget" manner, issuing a subscription query soon after connecting and remaining subscribed for the lifetime of the client connection.
