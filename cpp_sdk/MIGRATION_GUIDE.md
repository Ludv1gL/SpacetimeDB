# Migration Guide: From Legacy Module Definition to New Internal API

This guide explains how to migrate from the old module definition system to the new Internal API.

## Overview of Changes

The new Internal API provides a cleaner, more maintainable approach to module definition:

1. **Autogenerated Types**: Instead of manually defining `InternalModuleDef`, use autogenerated `RawModuleDefV9`
2. **Type-Safe Registration**: Use `Module::RegisterTable` and `Module::RegisterReducer` 
3. **Interface-Based Design**: Implement `ITable` and `IReducer` interfaces
4. **Automatic FFI Management**: No manual FFI export writing

## Migration Steps

### 1. Update Include Paths

**Old:**
```cpp
#include "spacetimedb/internal/module_schema.h"
#include "spacetimedb/internal/module_def.h" 
```

**New:**
```cpp
#include "spacetimedb/internal/Module.h"
#include "spacetimedb/internal/ITable.h"
#include "spacetimedb/internal/IReducer.h"
```

### 2. Table Registration

**Old:**
```cpp
SPACETIMEDB_TABLE(Person, "person", true, "")
// Plus manual schema registration
```

**New:**
```cpp
// Define row type
struct Person {
    uint32_t id;
    std::string name;
    
    void bsatn_serialize(bsatn::Writer& writer) const;
    void bsatn_deserialize(bsatn::Reader& reader);
};

// Define table view
class PersonTableView : public ITableView<PersonTableView, Person> {
public:
    static RawTableDefV9 MakeTableDesc(ITypeRegistrar& registrar) {
        RawTableDefV9 table;
        table.name = "person";
        table.table_access = TableAccess::Public;
        table.table_type = TableType::User;
        // Register type and get reference
        table.product_type_ref = registrar.RegisterType<Person>(
            [](AlgebraicTypeRef) -> std::vector<uint8_t> {
                // Generate AlgebraicType for Person
                // TODO: Implement type generation
                return {};
            }
        ).idx;
        return table;
    }
    
    static uint32_t GetTableId() {
        static uint32_t id = 0xFFFFFFFF;
        if (id == 0xFFFFFFFF) {
            std::string name = "person";
            FFI::table_id_from_name(
                reinterpret_cast<const uint8_t*>(name.data()),
                name.size(),
                &id
            );
        }
        return id;
    }
    
    static Person ReadGenFields(bsatn::Reader& reader, const Person& row) {
        Person result = row;
        // Read auto-generated fields (e.g., auto-increment id)
        result.id = reader.read_u32();
        return result;
    }
};

// Register in module initialization
Module::RegisterTable<Person, PersonTableView>();
```

### 3. Reducer Registration

**Old:**
```cpp
SPACETIMEDB_REDUCER(insert_person, name, age)
// Plus manual invoker registration
```

**New:**
```cpp
// Define reducer class
class InsertPersonReducer : public IReducer {
public:
    RawReducerDefV9 MakeReducerDef(ITypeRegistrar& registrar) override {
        RawReducerDefV9 reducer;
        reducer.name = "insert_person";
        // Register function type
        reducer.func_type_ref = registrar.RegisterType<void(std::string, uint8_t)>(
            [](AlgebraicTypeRef) -> std::vector<uint8_t> {
                // Generate function type
                // TODO: Implement
                return {};
            }
        ).idx;
        return reducer;
    }
    
    void Invoke(bsatn::Reader& reader, IReducerContext& ctx) override {
        // Deserialize arguments
        std::string name = reader.read_string();
        uint8_t age = reader.read_u8();
        
        // Execute reducer logic
        Person person{0, name, age};
        ctx.GetDb().GetTable<Person>("person").Insert(person);
    }
};

// Register in module initialization
Module::RegisterReducer<InsertPersonReducer>();
```

### 4. Module Initialization

**Old:**
```cpp
// Macros automatically registered everything
```

**New:**
```cpp
// In module initialization code
void InitializeModule() {
    // Set up reducer context factory
    Module::SetReducerContextConstructor(
        [](Identity sender, std::optional<ConnectionId> connId, 
           uint64_t seed, Timestamp ts) {
            return std::make_unique<MyReducerContext>(sender, connId, seed, ts);
        }
    );
    
    // Register tables
    Module::RegisterTable<Person, PersonTableView>();
    
    // Register reducers  
    Module::RegisterReducer<InsertPersonReducer>();
}
```

### 5. Remove Old Files

After migration, you can remove:
- Uses of `module_def.h` types
- Uses of `module_schema.h` types
- Manual FFI export implementations

## Benefits of New API

1. **Type Safety**: Compile-time checking of table/reducer registration
2. **Autogenerated Types**: No manual struct definitions for module metadata
3. **Better Error Handling**: Rich exceptions instead of error codes
4. **Cleaner Architecture**: Clear separation of concerns with interfaces
5. **Future-Proof**: Easy to extend with new features

## Compatibility

The new API is designed to work alongside the old system during migration. You can migrate incrementally, one table/reducer at a time.