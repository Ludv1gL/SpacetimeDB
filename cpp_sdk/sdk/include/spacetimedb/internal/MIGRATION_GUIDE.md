# C++ SDK Internal API Migration Guide

This guide explains how to migrate from the old manual module definition approach to the new Internal API that matches the C# SDK design.

## Overview

The new Internal API provides:
- Automatic module definition generation using autogenerated types
- Type-safe table and reducer registration
- FFI wrappers for database operations
- Consistent API across C++ and C# SDKs

## Key Changes

### 1. Module Definition Types

**Old approach:**
```cpp
// Manual struct definitions
struct RawTableDefV9 {
    std::string table_name;
    uint32_t product_type_ref;
    bool is_public;
};
```

**New approach:**
```cpp
// Use autogenerated types from internal/autogen/
#include "spacetimedb/internal/autogen/RawTableDefV9.g.h"
// Fully defined with all fields matching Rust definitions
```

### 2. Module Registration

**Old approach:**
```cpp
// Manual module building
auto module_def = build_raw_module_def_v9(schema);
```

**New approach:**
```cpp
#include "spacetimedb/internal/Module.h"

// Register tables
SpacetimeDb::Internal::Module::RegisterTable<Person, PersonTableView>();

// Register reducers  
SpacetimeDb::Internal::Module::RegisterReducer<InsertPersonReducer>();

// Module definition is built automatically
```

### 3. Table Implementation

**New approach:**
```cpp
// Define your row type
struct Person {
    uint32_t id;
    std::string name;
    uint8_t age;
    
    // BSATN serialization (can be auto-generated)
    void bsatn_serialize(SpacetimeDb::bsatn::Writer& writer) const;
    void bsatn_deserialize(SpacetimeDb::bsatn::Reader& reader);
};

// Define table view
class PersonTableView : public SpacetimeDb::Internal::ITableView<PersonTableView, Person> {
public:
    // Create table description
    static RawTableDefV9 MakeTableDesc(ITypeRegistrar& registrar) {
        RawTableDefV9 table;
        table.name = "person";
        table.product_type_ref = registrar.RegisterType<Person>([](AlgebraicTypeRef) {
            // Generate AlgebraicType for Person
            // This would typically be auto-generated
            return generatePersonType();
        }).idx;
        table.table_access = TableAccess::Public;
        table.table_type = TableType::User;
        // ... other fields
        return table;
    }
    
    // Read generated fields (e.g., auto-increment IDs)
    static Person ReadGenFields(bsatn::Reader& reader, Person row) {
        // Read any server-generated fields
        row.id = reader.read_u32_le();
        return row;
    }
    
    // Implement table operations
    uint64_t Count() const override { return DoCount(); }
    std::vector<Person> Iter() const override { return DoIter(); }
    Person Insert(const Person& row) override { return DoInsert(row); }
    bool Delete(const Person& row) override { return DoDelete(row); }
};
```

### 4. Reducer Implementation

**New approach:**
```cpp
class InsertPersonReducer : public SpacetimeDb::Internal::IReducer {
public:
    RawReducerDefV9 MakeReducerDef(ITypeRegistrar& registrar) const override {
        RawReducerDefV9 reducer;
        reducer.name = "insert_person";
        reducer.func_type_ref = registrar.RegisterType<void(std::string, uint8_t)>([](AlgebraicTypeRef) {
            // Generate function type
            return generateReducerType();
        }).idx;
        return reducer;
    }
    
    void Invoke(bsatn::Reader& reader, IReducerContext& ctx) override {
        // Deserialize arguments
        auto name = reader.read_string();
        auto age = reader.read_u8();
        
        // Execute reducer logic
        Person person{0, name, age};
        PersonTableView table;
        table.Insert(person);
    }
};
```

### 5. Module Exports

The module exports are now handled automatically:

```cpp
// These are called by the SpacetimeDB runtime
extern "C" {
    void __describe_module__(BytesSink description) {
        SpacetimeDb::Internal::Module::__describe_module__(description);
    }
    
    Errno __call_reducer__(/* parameters */) {
        return SpacetimeDb::Internal::Module::__call_reducer__(/* forward parameters */);
    }
}
```

## Benefits

1. **Type Safety**: All module definition types are generated from the Rust definitions
2. **Consistency**: Same API patterns as C# SDK
3. **Less Boilerplate**: Automatic registration and serialization
4. **Better Integration**: Uses the same autogenerated types across the codebase
5. **FFI Safety**: Proper error handling and type conversions

## Migration Steps

1. Replace manual struct definitions with includes from `internal/autogen/`
2. Implement `ITableView` for your tables
3. Implement `IReducer` for your reducers
4. Use `Module::RegisterTable` and `Module::RegisterReducer`
5. Update module exports to use `Module::__describe_module__` and `Module::__call_reducer__`

## Future Improvements

- Automatic BSATN serialization generation for user types
- Macro-based table and reducer definitions (similar to Rust)
- Query builder API
- Index management API