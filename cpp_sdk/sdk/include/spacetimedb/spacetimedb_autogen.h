#pragma once

/**
 * SpacetimeDB C++ SDK - Autogenerated Module Definition
 * 
 * This header provides automatic type registration and module definition
 * generation for SpacetimeDB modules.
 */

#include "spacetimedb.h"
#include <typeinfo>
#include <typeindex>

namespace spacetimedb {

// Type trait to get AlgebraicType tag for basic types
template<typename T>
struct AlgebraicTypeTag {
    static constexpr uint8_t value = 255; // Invalid by default
};

// Specializations for basic types
template<> struct AlgebraicTypeTag<uint8_t> { static constexpr uint8_t value = 7; };   // U8
template<> struct AlgebraicTypeTag<uint16_t> { static constexpr uint8_t value = 8; };  // U16
template<> struct AlgebraicTypeTag<uint32_t> { static constexpr uint8_t value = 9; };  // U32
template<> struct AlgebraicTypeTag<uint64_t> { static constexpr uint8_t value = 10; }; // U64
template<> struct AlgebraicTypeTag<int8_t> { static constexpr uint8_t value = 3; };    // I8
template<> struct AlgebraicTypeTag<int16_t> { static constexpr uint8_t value = 4; };   // I16
template<> struct AlgebraicTypeTag<int32_t> { static constexpr uint8_t value = 5; };   // I32
template<> struct AlgebraicTypeTag<int64_t> { static constexpr uint8_t value = 6; };   // I64
template<> struct AlgebraicTypeTag<float> { static constexpr uint8_t value = 12; };    // F32
template<> struct AlgebraicTypeTag<double> { static constexpr uint8_t value = 13; };   // F64
template<> struct AlgebraicTypeTag<bool> { static constexpr uint8_t value = 11; };     // Bool
template<> struct AlgebraicTypeTag<std::string> { static constexpr uint8_t value = 15; }; // String

// Field information for type registration
struct FieldInfo {
    std::string name;
    uint8_t algebraic_type_tag;
    std::function<void(BsatnWriter&, const void*)> serializer;
};

// Type information for registration
struct TypeInfo {
    std::type_index type_id;
    std::vector<FieldInfo> fields;
    std::string name;
    
    TypeInfo(std::type_index tid) : type_id(tid) {}
};

// Enhanced module definition builder with type support
class AutogenModuleDefBuilder {
    std::vector<TypeInfo> types_;
    std::vector<TableInfo> tables_;
    std::vector<ReducerInfo> reducers_;
    std::unordered_map<std::type_index, uint32_t> type_to_ref_;
    
public:
    // Register a type with its fields
    void register_type(std::type_index type_id, const std::string& name, const std::vector<FieldInfo>& fields) {
        if (type_to_ref_.find(type_id) == type_to_ref_.end()) {
            uint32_t ref = types_.size();
            type_to_ref_[type_id] = ref;
            types_.push_back(TypeInfo(type_id));
            types_.back().name = name;
            types_.back().fields = fields;
        }
    }
    
    // Register a table with automatic type registration
    template<typename T>
    void register_table(const std::string& name, bool is_public) {
        std::type_index type_id = std::type_index(typeid(T));
        
        // Ensure type is registered (user must call register_type first)
        auto it = type_to_ref_.find(type_id);
        if (it != type_to_ref_.end()) {
            tables_.push_back({name, is_public, it->second});
        } else {
            // Type not registered - use ref 0 as fallback
            tables_.push_back({name, is_public, 0});
        }
    }
    
    void register_reducer(const std::string& name, const std::vector<std::string>& param_types = {},
                         std::optional<uint8_t> lifecycle = std::nullopt) {
        reducers_.push_back({name, param_types, lifecycle});
    }
    
    std::vector<uint8_t> build() {
        std::vector<uint8_t> result;
        BsatnWriter writer(result);
        
        // RawModuleDef::V9 tag
        writer.write_u8(1);
        
        // RawModuleDefV9 structure:
        
        // 1. typespace: Typespace
        write_typespace(writer);
        
        // 2. tables: Vec<RawTableDefV9>
        write_tables(writer);
        
        // 3. reducers: Vec<RawReducerDefV9>
        write_reducers(writer);
        
        // 4. types: Vec<RawTypeDefV9> (empty for now)
        writer.write_vec_len(0);
        
        // 5. misc_exports: Vec<RawMiscModuleExportV9> (empty)
        writer.write_vec_len(0);
        
        // 6. row_level_security: Vec<RawRowLevelSecurityDefV9> (empty)
        writer.write_vec_len(0);
        
        return result;
    }
    
private:
    void write_typespace(BsatnWriter& writer) {
        // types: Vec<AlgebraicType>
        writer.write_vec_len(types_.size());
        
        for (const auto& type : types_) {
            // Write Product type
            writer.write_u8(2); // AlgebraicType::Product
            writer.write_vec_len(type.fields.size());
            
            for (const auto& field : type.fields) {
                // ProductTypeElement
                writer.write_u8(0); // Option::Some for name
                writer.write_string(field.name);
                writer.write_u8(field.algebraic_type_tag);
            }
        }
        
        // names: Vec<ScopedTypeName> (empty for now)
        writer.write_vec_len(0);
    }
    
    void write_tables(BsatnWriter& writer) {
        writer.write_vec_len(tables_.size());
        
        for (const auto& table : tables_) {
            writer.write_string(table.name);           // name
            writer.write_u32(table.product_type_ref);  // product_type_ref
            writer.write_u8(1);                        // primary_key: None
            writer.write_vec_len(0);                   // indexes
            writer.write_vec_len(0);                   // constraints
            writer.write_vec_len(0);                   // sequences
            writer.write_u8(1);                        // schedule: None
            writer.write_u8(0);                        // table_type: User
            writer.write_u8(table.is_public ? 0 : 1);  // table_access
        }
    }
    
    void write_reducers(BsatnWriter& writer) {
        writer.write_vec_len(reducers_.size());
        
        for (const auto& reducer : reducers_) {
            writer.write_string(reducer.name);         // name
            writer.write_vec_len(0);                   // params (empty product for now)
            
            if (reducer.lifecycle.has_value()) {
                writer.write_u8(0); // Some tag
                writer.write_u8(reducer.lifecycle.value());
            } else {
                writer.write_u8(1); // None tag
            }
        }
    }
};

// Global registry with autogen support
class AutogenModuleRegistry {
    AutogenModuleDefBuilder builder_;
    
    AutogenModuleRegistry() = default;
    
public:
    static AutogenModuleRegistry& instance() {
        static AutogenModuleRegistry registry;
        return registry;
    }
    
    // Register a type with its fields
    void register_type(std::type_index type_id, const std::string& name, const std::vector<FieldInfo>& fields) {
        builder_.register_type(type_id, name, fields);
    }
    
    // Register a table
    template<typename T>
    void register_table(const std::string& name, bool is_public) {
        builder_.register_table<T>(name, is_public);
    }
    
    void register_reducer(const std::string& name, 
                         const std::vector<std::string>& param_types = {},
                         std::optional<uint8_t> lifecycle = std::nullopt) {
        builder_.register_reducer(name, param_types, lifecycle);
    }
    
    std::vector<uint8_t> build_module_def() {
        return builder_.build();
    }
};

// Field registration helper
template<typename T, typename FieldType>
FieldInfo make_field(const std::string& name, FieldType T::*member_ptr) {
    return {
        name,
        AlgebraicTypeTag<FieldType>::value,
        [member_ptr](BsatnWriter& writer, const void* obj) {
            const T* typed_obj = static_cast<const T*>(obj);
            const FieldType& value = typed_obj->*member_ptr;
            
            // Serialize based on type
            if constexpr (std::is_same_v<FieldType, std::string>) {
                writer.write_string(value);
            } else if constexpr (std::is_same_v<FieldType, uint8_t>) {
                writer.write_u8(value);
            } else if constexpr (std::is_same_v<FieldType, uint16_t>) {
                writer.write_u16(value);
            } else if constexpr (std::is_same_v<FieldType, uint32_t>) {
                writer.write_u32(value);
            } else if constexpr (std::is_same_v<FieldType, uint64_t>) {
                writer.write_u64(value);
            } else if constexpr (std::is_integral_v<FieldType> || std::is_floating_point_v<FieldType>) {
                // For other numeric types, write raw bytes
                auto& buffer = writer.get_buffer();
                const uint8_t* bytes = reinterpret_cast<const uint8_t*>(&value);
                buffer.insert(buffer.end(), bytes, bytes + sizeof(value));
            }
        }
    };
}

} // namespace spacetimedb

// =============================================================================
// ENHANCED REGISTRATION MACROS
// =============================================================================

// Register fields for a struct type
#define SPACETIMEDB_REGISTER_TYPE(type, ...) \
    namespace { \
        struct type##_type_registrar { \
            type##_type_registrar() { \
                std::vector<spacetimedb::FieldInfo> fields = { __VA_ARGS__ }; \
                spacetimedb::AutogenModuleRegistry::instance().register_type( \
                    std::type_index(typeid(type)), #type, fields); \
            } \
        }; \
        static type##_type_registrar type##_type_reg_; \
    }

// Helper macro to define a field
#define SPACETIMEDB_FIELD(type, field) \
    spacetimedb::make_field<type>(#field, &type::field)

// Enhanced table registration that uses registered type
#define SPACETIMEDB_TABLE_AUTO(type, name, is_public) \
    namespace { \
        struct type##_table_auto_registrar { \
            type##_table_auto_registrar() { \
                spacetimedb::get_module_db()->register_table<type>(#name); \
                spacetimedb::AutogenModuleRegistry::instance().register_table<type>(#name, is_public); \
            } \
        }; \
        static type##_table_auto_registrar type##_table_auto_reg_; \
    } \
    template<> \
    struct spacetimedb::Serializer<type> { \
        static void serialize(BsatnWriter& writer, const type& value) { \
            auto& registry = AutogenModuleRegistry::instance(); \
            std::type_index type_id(typeid(type)); \
            /* TODO: Use registered field serializers */ \
            type::spacetimedb_serialize(writer.get_buffer(), value); \
        } \
    };

// Serializer trait for automatic serialization
namespace spacetimedb {
    template<typename T>
    struct Serializer {
        static void serialize(BsatnWriter& writer, const T& value) {
            // Default: call user-provided method
            T::spacetimedb_serialize(writer.get_buffer(), value);
        }
    };
}

