# BSATN C++ Implementation - Final Plan

## Current Status Summary

The C++ BSATN implementation has been **significantly refactored** to align with Rust/C# naming conventions and provides **excellent core functionality** with some remaining gaps to address.

## ✅ Completed (Working Well)

### 1. Core Type System Refactoring
- **SumType<T...>** (renamed from Sum, with backward compatibility)
- **ProductTypeElement**, **SumTypeVariant** (aligned with Rust/C# naming)
- **Unified spacetimedb::bsatn namespace** with legacy compatibility
- **Header consolidation** - single entry point via `spacetimedb/spacetimedb.h`

### 2. Primitive Type Support (Perfect)
All SpacetimeDB primitive types fully implemented:
```cpp
bool, int8_t, int16_t, int32_t, int64_t
uint8_t, uint16_t, uint32_t, uint64_t
float, double, std::string
int128_t_placeholder, uint128_t_placeholder // Extended integers
```

### 3. Container Types (Perfect)
- **std::vector<T>** - length-prefixed serialization
- **std::optional<T>** - tag-based encoding (0=None, 1=Some)
- **SumType<T...>** - discriminated unions with variant index

### 4. User-Defined Structs (Very Good)
```cpp
struct MyStruct {
    int32_t id;
    std::string name;
    std::optional<float> score;
};
SPACETIMEDB_BSATN_STRUCT(MyStruct, id, name, score)
```
- Macro generates serialize/deserialize methods
- Field-by-field serialization in order
- Basic AlgebraicType metadata generation

## ❌ Major Gaps to Address

### 1. Type Registry System (Critical)
**Problem:** AlgebraicType metadata references are incomplete
```cpp
// Current TODOs indicate missing functionality:
elements.emplace_back(name, 0); // TODO: fix type index
```

**Need to implement:**
- Working type registry for managing type indices
- Proper type reference resolution
- Circular dependency handling

### 2. Special Type Handling (Missing)
**Problem:** SpacetimeDB special types not properly integrated
```rust
// Rust defines these tags:
pub const IDENTITY_TAG: &str = "__identity__";
pub const CONNECTION_ID_TAG: &str = "__connection_id__";
pub const TIMESTAMP_TAG: &str = "__timestamp_micros_since_unix_epoch__";
pub const TIME_DURATION_TAG: &str = "__time_duration_micros__";
```

**Need to implement:**
- Special type tag constants
- Detection logic for special types in ProductType
- Integration with AlgebraicType system

### 3. Autogenerated Type Integration (Incomplete)
**Problem:** Generated types may not serialize correctly with BSATN
- Autogenerated files use `SpacetimeDb::Internal` namespace
- Need to verify compatibility with `spacetimedb::bsatn` system
- Ensure proper serialization traits are generated

## Implementation Plan

### Phase 1: Core Infrastructure (High Priority)

#### 1.1 Implement Type Registry
```cpp
class TypeRegistry {
    std::vector<AlgebraicType> types_;
    std::unordered_map<std::string, uint32_t> named_types_;
public:
    uint32_t register_type(AlgebraicType type);
    uint32_t register_named_type(const std::string& name, AlgebraicType type);
    const AlgebraicType& get_type(uint32_t id) const;
    std::optional<uint32_t> find_type(const std::string& name) const;
};
```

#### 1.2 Add Special Type Support
```cpp
namespace spacetimedb::bsatn {
    constexpr const char* IDENTITY_TAG = "__identity__";
    constexpr const char* CONNECTION_ID_TAG = "__connection_id__";
    constexpr const char* TIMESTAMP_TAG = "__timestamp_micros_since_unix_epoch__";
    constexpr const char* TIME_DURATION_TAG = "__time_duration_micros__";
    
    bool is_special_type(const ProductType& product);
    SpecialTypeKind get_special_type_kind(const ProductType& product);
}
```

#### 1.3 Fix AlgebraicType Metadata Generation
- Complete `algebraic_type_of<T>` for containers
- Fix type index resolution in ProductTypeBuilder/SumTypeBuilder
- Add proper recursive type handling

### Phase 2: Integration (High Priority)

#### 2.1 Autogenerated Type Compatibility
- Verify generated types work with BSATN serialization
- Add proper `bsatn_serialize`/`bsatn_deserialize` generation
- Ensure namespace compatibility between `SpacetimeDb::Internal` and `spacetimedb::bsatn`

#### 2.2 Module Definition Integration
- Ensure BSATN types properly integrate with module schema generation
- Fix type registry usage in module definition system
- Verify roundtrip compatibility with Rust/C# modules

### Phase 3: Testing & Validation (Medium Priority)

#### 3.1 Comprehensive Test Suite
- Test all primitive types (done)
- Test complex nested structures
- Test special types (Identity, Timestamp, etc.)
- Test autogenerated type serialization
- Test cross-language compatibility

#### 3.2 Performance Testing
- Benchmark serialization/deserialization
- Memory usage validation
- Large data handling tests

### Phase 4: Final Refactoring (Low Priority)

#### 4.1 Code Compaction
- Remove redundant code patterns
- Consolidate similar functionality
- Optimize template instantiation

#### 4.2 Readability Improvements
- Improve documentation and comments
- Simplify complex template expressions
- Add usage examples

## Success Criteria

### ✅ Must Have (Core Functionality)
1. All primitive and container types serialize correctly
2. User-defined structs work with macro system
3. Type registry provides working metadata
4. Special types (Identity, etc.) serialize with proper tags
5. Autogenerated types integrate seamlessly

### ✅ Should Have (Production Ready)
1. Comprehensive test coverage (>95%)
2. Cross-language compatibility verified
3. Performance acceptable for production use
4. Clear documentation and examples

### ✅ Nice to Have (Polish)
1. Optimized binary size
2. Minimal compile-time overhead
3. Excellent error messages
4. Extensive static analysis clean

## Current Priority Order

1. **Type Registry Implementation** - Fixes AlgebraicType metadata
2. **Special Type Handling** - Completes SpacetimeDB type system
3. **Autogen Integration** - Ensures generated code works
4. **Comprehensive Testing** - Validates all functionality
5. **Final Refactoring** - Polish and optimization

The implementation is **~75% complete** with solid foundations and excellent core functionality. The remaining work focuses on completing the type metadata system and ensuring full integration with SpacetimeDB's module system.