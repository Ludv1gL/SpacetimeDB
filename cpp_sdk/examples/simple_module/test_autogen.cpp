#include "../../sdk/include/spacetimedb/spacetimedb_autogen.h"
#include <cstdio>

// Define a simple table structure
struct Person {
    uint32_t id;
    std::string name;
    uint8_t age;
    
    // Still need this for now until full autogen is implemented
    static void spacetimedb_serialize(std::vector<uint8_t>& buffer, const Person& value) {
        // Serialize id
        buffer.insert(buffer.end(), reinterpret_cast<const uint8_t*>(&value.id), 
                     reinterpret_cast<const uint8_t*>(&value.id) + sizeof(value.id));
        
        // Serialize name (length + string)
        uint32_t name_len = value.name.length();
        buffer.insert(buffer.end(), reinterpret_cast<const uint8_t*>(&name_len),
                     reinterpret_cast<const uint8_t*>(&name_len) + sizeof(name_len));
        buffer.insert(buffer.end(), value.name.begin(), value.name.end());
        
        // Serialize age
        buffer.push_back(value.age);
    }
};

// Register the Person type with its fields
SPACETIMEDB_REGISTER_TYPE(Person,
    SPACETIMEDB_FIELD(Person, id),
    SPACETIMEDB_FIELD(Person, name),
    SPACETIMEDB_FIELD(Person, age)
)

// Register the table using the registered type
SPACETIMEDB_TABLE_AUTO(Person, person, true)

// Test reducer that inserts a person (args will be added later)
SPACETIMEDB_REDUCER(add_person, spacetimedb::ReducerContext ctx) {
    static uint32_t next_id = 1;
    
    // For now, use hardcoded values
    std::string name = "Test User";
    uint8_t age = 25;
    
    Person person{next_id++, name, age};
    
    bool success = ctx.db->table<Person>("person").insert(person);
    
    if (success) {
        char msg[256];
        snprintf(msg, sizeof(msg), "Added person: %s (age %d) with ID %d", 
                 name.c_str(), age, person.id);
        LOG_INFO(msg);
    } else {
        LOG_ERROR("Failed to add person");
    }
}

// Init reducer
SPACETIMEDB_INIT(init) {
    LOG_INFO("Autogen module initialized");
    
    // Add a default person
    static uint32_t next_id = 1;
    Person admin{next_id++, "Admin", 30};
    
    bool success = ctx.db->table<Person>("person").insert(admin);
    if (success) {
        LOG_INFO("Created default admin user");
    }
}

// Required exports for SpacetimeDB modules
extern "C" __attribute__((export_name("__describe_module__"))) 
void __describe_module__(uint32_t description) {
    // Use the autogenerated module definition
    auto module_def = spacetimedb::AutogenModuleRegistry::instance().build_module_def();
    
    // Write to sink
    size_t total_size = module_def.size();
    size_t written = 0;
    
    while (written < total_size) {
        size_t chunk_size = std::min(size_t(1024), total_size - written);
        size_t write_size = chunk_size;
        
        uint16_t result = bytes_sink_write(description, 
                                          module_def.data() + written, 
                                          &write_size);
        
        if (result != 0) {
            break;
        }
        
        written += write_size;
    }
}

extern "C" __attribute__((export_name("__call_reducer__"))) 
int16_t __call_reducer__(uint32_t id, 
                        uint64_t sender_0, uint64_t sender_1, uint64_t sender_2, uint64_t sender_3,
                        uint64_t conn_id_0, uint64_t conn_id_1, 
                        uint64_t timestamp,
                        uint32_t args, uint32_t error) {
    try {
        // Construct identity from parameters
        auto sender_identity = identity_from_params(sender_0, sender_1, sender_2, sender_3);
        
        // Construct connection ID if valid
        std::optional<spacetimedb::ConnectionId> conn_id;
        if (conn_id_0 != 0 || conn_id_1 != 0) {
            conn_id = spacetimedb::ConnectionId(conn_id_0, conn_id_1);
        }
        
        // Create reducer context with all information
        spacetimedb::ReducerContext ctx(spacetimedb::get_module_db(), 
                                       sender_identity, 
                                       timestamp, 
                                       conn_id);
        
        // Dispatch to the appropriate reducer
        if (!spacetimedb::ReducerDispatcher::instance().call_reducer(id, ctx, args)) {
            return 1; // Unknown reducer
        }
        
        return 0; // Success
    } catch (const std::exception& e) {
        LOG_ERROR(std::string("Error in __call_reducer__: ") + e.what());
        return 1;
    }
}