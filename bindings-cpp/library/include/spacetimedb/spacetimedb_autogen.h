#pragma once

/**
 * SpacetimeDB C++ SDK - Autogenerated Module Definition
 * 
 * This header provides automatic type registration and module definition
 * generation for SpacetimeDB modules.
 */

#include "spacetimedb.h"
#include "bsatn/type_registry.h"
#include "bsatn/algebraic_type.h"
#include "bsatn/traits.h"
#include "rls.h"
#include <typeinfo>
#include <typeindex>

namespace SpacetimeDb {

// Table information for module definition
struct TableInfo {
    std::string name;
    bool is_public;
    uint32_t product_type_ref;
};

// Reducer information for module definition
struct ReducerInfo {
    std::string name;
    std::vector<std::string> param_types;
    std::optional<uint8_t> lifecycle;
};

// Field information for type registration
struct FieldInfo {
    std::string name;
    std::function<SpacetimeDb::bsatn::AlgebraicType()> get_algebraic_type;
    std::function<void(BsatnWriter&, const void*)> serializer;
};

// Type information for registration
struct TypeInfo {
    std::type_index type_id;
    std::vector<FieldInfo> fields;
    std::string name;
    uint32_t type_ref; // Reference in the type registry
    
    TypeInfo(std::type_index tid) : type_id(tid), type_ref(0) {}
};

// Enhanced module definition builder with type support
class AutogenModuleDefBuilder {
    std::vector<TypeInfo> types_;
    std::vector<TableInfo> tables_;
    std::vector<ReducerInfo> reducers_;
    std::unordered_map<std::type_index, uint32_t> type_to_ref_;
    SpacetimeDb::bsatn::TypeRegistry type_registry_;
    
public:
    // Register a type with its fields
    void register_type(std::type_index type_id, const std::string& name, const std::vector<FieldInfo>& fields) {
        if (type_to_ref_.find(type_id) == type_to_ref_.end()) {
            // Build the product type for this struct
            std::vector<SpacetimeDb::bsatn::ProductTypeElement> elements;
            for (const auto& field : fields) {
                auto field_type = field.get_algebraic_type();
                elements.emplace_back(field.name, std::move(field_type));
            }
            
            auto product_type = SpacetimeDb::bsatn::AlgebraicType::make_product(
                std::make_unique<SpacetimeDb::bsatn::ProductType>(std::move(elements))
            );
            
            // Register in the type registry
            uint32_t ref = type_registry_.register_named_type(name, std::move(product_type));
            type_to_ref_[type_id] = ref;
            
            types_.push_back(TypeInfo(type_id));
            types_.back().name = name;
            types_.back().fields = fields;
            types_.back().type_ref = ref;
        }
    }
    
    // Register a table with automatic type registration
    template<typename T>
    void register_table(const std::string& name, bool is_public) {
        std::type_index type_id = std::type_index(typeid(T));
        
        // Ensure type is registered (user must call register_type first)
        auto it = type_to_ref_.find(type_id);
        if (it != type_to_ref_.end()) {
            tables_.push_back({name, is_public, it->second});
        } else {
            // Type not registered - use ref 0 as fallback
            tables_.push_back({name, is_public, 0});
        }
    }
    
    void register_reducer(const std::string& name, const std::vector<std::string>& param_types = {},
                         std::optional<uint8_t> lifecycle = std::nullopt) {
        reducers_.push_back({name, param_types, lifecycle});
    }
    
    // Register a reducer with parameter type references
    void register_reducer_with_types(const std::string& name, const std::vector<uint32_t>& param_type_refs,
                                   std::optional<uint8_t> lifecycle = std::nullopt) {
        // Convert type refs to names for now
        std::vector<std::string> param_names;
        for (uint32_t ref : param_type_refs) {
            param_names.push_back("type_" + std::to_string(ref));
        }
        reducers_.push_back({name, param_names, lifecycle});
    }
    
    std::vector<uint8_t> build() {
        std::vector<uint8_t> result;
        BsatnWriter writer(result);
        
        // RawModuleDef::V9 tag
        writer.write_u8(1);
        
        // RawModuleDefV9 structure:
        
        // 1. typespace: Typespace
        write_typespace(writer);
        
        // 2. tables: Vec<RawTableDefV9>
        write_tables(writer);
        
        // 3. reducers: Vec<RawReducerDefV9>
        write_reducers(writer);
        
        // 4. types: Vec<RawTypeDefV9> (empty for now)
        writer.write_vec_len(0);
        
        // 5. misc_exports: Vec<RawMiscModuleExportV9> (empty)
        writer.write_vec_len(0);
        
        // 6. row_level_security: Vec<RawRowLevelSecurityDefV9>
        RlsPolicyRegistry::instance().write_policies(writer);
        
        return result;
    }
    
private:
    void write_typespace(BsatnWriter& writer) {
        // Build the complete typespace
        // First, ensure all registered types are in the registry
        
        // types: Vec<AlgebraicType>
        // For now, we'll write the types we've registered
        writer.write_vec_len(types_.size());
        
        for (const auto& type : types_) {
            // Get the registered AlgebraicType from the registry
            const auto& alg_type = type_registry_.get_type(type.type_ref);
            alg_type.write_bsatn(writer);
        }
        
        // names: Vec<ScopedTypeName>
        // Include named types
        writer.write_vec_len(types_.size());
        for (const auto& type : types_) {
            // ScopedTypeName structure
            writer.write_vec_len(0); // scope (empty for now)
            writer.write_string(type.name); // name
            writer.write_u32(type.type_ref); // type_ref
        }
    }
    
    void write_tables(BsatnWriter& writer) {
        writer.write_vec_len(tables_.size());
        
        for (const auto& table : tables_) {
            writer.write_string(table.name);           // name
            writer.write_u32(table.product_type_ref);  // product_type_ref
            writer.write_u8(1);                        // primary_key: None
            writer.write_vec_len(0);                   // indexes
            writer.write_vec_len(0);                   // constraints
            writer.write_vec_len(0);                   // sequences
            writer.write_u8(1);                        // schedule: None
            writer.write_u8(0);                        // table_type: User
            writer.write_u8(table.is_public ? 0 : 1);  // table_access
        }
    }
    
    void write_reducers(BsatnWriter& writer) {
        writer.write_vec_len(reducers_.size());
        
        for (const auto& reducer : reducers_) {
            writer.write_string(reducer.name);         // name
            
            // params: ProductType
            // For now, create a product type with named parameters
            writer.write_u8(2); // AlgebraicType::Product tag
            writer.write_vec_len(reducer.param_types.size());
            
            for (size_t i = 0; i < reducer.param_types.size(); ++i) {
                // ProductTypeElement
                writer.write_u8(0); // Option::Some for name
                writer.write_string("arg" + std::to_string(i)); // parameter name
                
                // Try to resolve the type by name
                if (reducer.param_types[i].find("type_") == 0) {
                    // It's a type reference
                    uint32_t ref = std::stoul(reducer.param_types[i].substr(5));
                    writer.write_u8(0); // AlgebraicType::Ref tag
                    writer.write_u32(ref);
                } else {
                    // Try to map common type names
                    const std::string& type_name = reducer.param_types[i];
                    if (type_name == "u32" || type_name == "uint32_t") {
                        writer.write_u8(9); // U32
                    } else if (type_name == "u64" || type_name == "uint64_t") {
                        writer.write_u8(10); // U64
                    } else if (type_name == "i32" || type_name == "int32_t") {
                        writer.write_u8(5); // I32
                    } else if (type_name == "i64" || type_name == "int64_t") {
                        writer.write_u8(6); // I64
                    } else if (type_name == "string" || type_name == "std::string") {
                        writer.write_u8(15); // String
                    } else if (type_name == "bool") {
                        writer.write_u8(11); // Bool
                    } else {
                        // Unknown type - use unit type as placeholder
                        writer.write_u8(2); // Product
                        writer.write_vec_len(0); // Empty product (unit type)
                    }
                }
            }
            
            if (reducer.lifecycle.has_value()) {
                writer.write_u8(0); // Some tag
                writer.write_u8(reducer.lifecycle.value());
            } else {
                writer.write_u8(1); // None tag
            }
        }
    }
};

// Global registry with autogen support
class AutogenModuleRegistry {
    AutogenModuleDefBuilder builder_;
    
    AutogenModuleRegistry() = default;
    
public:
    static AutogenModuleRegistry& instance() {
        static AutogenModuleRegistry registry;
        return registry;
    }
    
    // Register a type with its fields
    void register_type(std::type_index type_id, const std::string& name, const std::vector<FieldInfo>& fields) {
        builder_.register_type(type_id, name, fields);
    }
    
    // Register a table
    template<typename T>
    void register_table(const std::string& name, bool is_public) {
        builder_.register_table<T>(name, is_public);
    }
    
    void register_reducer(const std::string& name, 
                         const std::vector<std::string>& param_types = {},
                         std::optional<uint8_t> lifecycle = std::nullopt) {
        builder_.register_reducer(name, param_types, lifecycle);
    }
    
    std::vector<uint8_t> build_module_def() {
        return builder_.build();
    }
};

// Field registration helper
template<typename T, typename FieldType>
FieldInfo make_field(const std::string& name, FieldType T::*member_ptr) {
    return {
        name,
        []() -> SpacetimeDb::bsatn::AlgebraicType {
            return SpacetimeDb::bsatn::algebraic_type_of<FieldType>::get();
        },
        [member_ptr](BsatnWriter& writer, const void* obj) {
            const T* typed_obj = static_cast<const T*>(obj);
            const FieldType& value = typed_obj->*member_ptr;
            
            // Use BSATN traits for serialization
            if constexpr (requires { SpacetimeDb::bsatn::bsatn_traits<FieldType>::serialize(writer, value); }) {
                SpacetimeDb::bsatn::bsatn_traits<FieldType>::serialize(writer, value);
            } else {
                // Fallback to basic serialization
                if constexpr (std::is_same_v<FieldType, std::string>) {
                    writer.write_string(value);
                } else if constexpr (std::is_same_v<FieldType, uint8_t>) {
                    writer.write_u8(value);
                } else if constexpr (std::is_same_v<FieldType, uint16_t>) {
                    writer.write_u16(value);
                } else if constexpr (std::is_same_v<FieldType, uint32_t>) {
                    writer.write_u32(value);
                } else if constexpr (std::is_same_v<FieldType, uint64_t>) {
                    writer.write_u64(value);
                } else if constexpr (std::is_integral_v<FieldType> || std::is_floating_point_v<FieldType>) {
                    // For other numeric types, write raw bytes
                    auto& buffer = writer.get_buffer();
                    const uint8_t* bytes = reinterpret_cast<const uint8_t*>(&value);
                    buffer.insert(buffer.end(), bytes, bytes + sizeof(value));
                }
            }
        }
    };
}

} // namespace SpacetimeDb

// =============================================================================
// ENHANCED REGISTRATION MACROS
// =============================================================================

// Register fields for a struct type
#define SPACETIMEDB_REGISTER_TYPE(type, ...) \
    namespace { \
        struct type##_type_registrar { \
            type##_type_registrar() { \
                std::vector<SpacetimeDb::FieldInfo> fields = { __VA_ARGS__ }; \
                SpacetimeDb::AutogenModuleRegistry::instance().register_type( \
                    std::type_index(typeid(type)), #type, fields); \
            } \
        }; \
        static type##_type_registrar type##_type_reg_; \
    }

// Helper macro to define a field
#define SPACETIMEDB_FIELD(type, field) \
    SpacetimeDb::make_field<type>(#field, &type::field)

// Helper macro to define a field with renamed database column
#define SPACETIMEDB_FIELD_RENAMED(type, field, db_name) \
    SpacetimeDb::make_field<type>(db_name, &type::field)

// Enhanced table registration that uses registered type
#define SPACETIMEDB_TABLE_AUTO(type, name, is_public) \
    namespace { \
        struct type##_table_auto_registrar { \
            type##_table_auto_registrar() { \
                SpacetimeDb::get_module_db()->register_table<type>(#name); \
                SpacetimeDb::AutogenModuleRegistry::instance().register_table<type>(#name, is_public); \
            } \
        }; \
        static type##_table_auto_registrar type##_table_auto_reg_; \
    } \
    template<> \
    struct SpacetimeDb::Serializer<type> { \
        static void serialize(BsatnWriter& writer, const type& value) { \
            auto& registry = AutogenModuleRegistry::instance(); \
            std::type_index type_id(typeid(type)); \
            /* TODO: Use registered field serializers */ \
            type::spacetimedb_serialize(writer.get_buffer(), value); \
        } \
    };

// Serializer trait for automatic serialization
namespace SpacetimeDb {
    template<typename T>
    struct Serializer {
        static void serialize(BsatnWriter& writer, const T& value) {
            // Default: call user-provided method
            T::spacetimedb_serialize(writer.get_buffer(), value);
        }
    };
}

